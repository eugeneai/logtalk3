..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Если это не требуется законодательством или не согласовано в письменной форме, программное обеспечение
   распространяется по лицензии на условиях "КАК ЕСТЬ".,
   БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых.
   См. лицензию для конкретного языка, регулирующего разрешения и
   ограничения, предусмотренные Лицензией.


.. _debugging_debugging:

Отладка
=======

Дистрибутив Logtalk включает в себя инструмент командной строки :doc:`../devtools/debugger`, реализованный в виде приложения Logtalk. Его можно запустить, набрав:

.. code-block:: text

   | ?- logtalk_load(debugger(loader)).

Он также может быть загружен автоматически во время запуска с помощью :term: `settings file`. Отладчик реализует функции, аналогичные тем, что встречаются в большинстве систем Prolog. Однако существуют и некоторые различия между обычной реализацией отладчиков Prolog и текущей отладчиком Logtalk, о которых следует упомянуть. Во-первых, в отличие от большинства отладчиков Prolog, отладчик Logtalk не является встроенной функцией, он - обычное приложение Logtalk, использующее задокументированные предикаты отладки.
Отладчик включает свой, хотя и схожий набор функций отладки по сравнению с некоторыми более сложными отладчиками Prolog. Во-вторых, отладка возможна только для сущностей, скомпилированных в режиме отладки. В этом режиме компиляции, Logtalk окружает утверждения информацией об исходном коде, позволяющей отслеживать достижение цели. В-третьих, реализация точек останова позволяет пользователю указывать
:term:`execution context <predicate execution context>` для входа в отладчик. Эта функция появилась из-за инкапсуляции предикатов внутри объектов.

.. _debugging_debug_mode:

Компиляция исходных файлов в режиме отладки
-------------------------------------------

Компиляция исходных файлов в режиме отладки контролируется флагом компилятора
:ref:`debug <flag_debug>`. Значение по умолчанию для этого флага, как правило, ``off``, оно задается в файлах адаптера. Значение флага можно изменить во время выполнения программы при помощи вызова:

.. code-block:: text

   | ?- set_logtalk_flag(debug, on).

Если надо скомпилировать только некоторые исходные файлы в режиме отладки, используется:

.. code-block:: text

   | ?- logtalk_load([file1, file2, ...], [debug(on)]).

Встроенный предикат :ref:`predicates_logtalk_make_1` позволяет перекомпилировать все загруженные файлы (которые были скомпилированы без явного использования необходимых значений флагов компилятора :ref:`debug <flag_debug>` и :ref:`optimize <flag_optimize>` в вызове `logtalk_load/2` или в файле :term:`loader file`) в режиме отладки:

.. code-block:: text

   | ?- logtalk_make(debug).

В большинстве компиляторов Prolog (:term:`backend Prolog compilers <backend Prolog compiler>`) также можно использовать директиву командной строки интерпретатора ``{+d}``. После отладки файлы можно перекомпилировать в обычном или оптимизированном режиме, используя, соответственно, ``{+n}`` или ``{+o}``.

Во время выполнения программы флаг компилятора :ref:`clean <flag_clean>` должен быть включен, если включен флаг :ref:`debug <flag_debug>`. Теперь отладочный код будет сгенерирован по новой для файлов, ранее скомпилированных в обычном режиме, если в исходных файлах обнаружатся изменения.

После загрузки отладчика можно перечислить при помощи бектрекинга все загруженные объекты, скомпилированные в режиме отладки, следующим образом:

.. code-block:: text

   | ?- debugger::debugging(Entity).

Чтобы скомпилировать только определенный объект в режиме отладки, используйте
:ref:`directives_set_logtalk_flag_2` внутри этого объекта.

.. _debugging_box_model:

Вычислительная модель отладчика
-------------------------------

Logtalk использует *модель вычисляющего ящика*, аналогичную тем, которые встречаются в большинстве системы Prolog. Традиционная вычислительная модель Prolog определяет четыре порта (*вызов*, *выход*, *повтор * и *сбой*), соответственно (*call*, *exit*, *redo*, and *fail*), для описания потока управления при вызове предиката:

| ``call``
|    вызов предиката
| ``exit``
|    успешный вызов предиката
| ``redo``
|    бэктрекинг к следующей фразе предиката
| ``fail``
|    неудача при вызове предиката

Logtalk использует найденный в некоторых современных системах Prolog порт для
обработки исключений, возникающих при вызове предиката:

| ``exception``
|    вызов предиката генерирует исключение

В дополнение к портам, описанным выше, Logtalk добавляет еще два порта,
``fact`` и ``rule``, которые показывают результат унификации цели с, соответственно, фактом и заголовком правила:

| ``fact``
|    успешная унификация цели и факта
| ``rule``
|    успешная унификация цели и заголовка правила

Следуя традициям Prolog, пользователь может определить, для каких портов
отладчик должен приостанавливать вычисления для взаимодействия с пользователем, указав список *leash*-портов. Например:

.. code-block:: text

   | ?- debugger::leash([call, exit, fail]).

Пользователь также может указать идентификатор предварительно определенного
набора портов. Например:

.. code-block:: text

   | ?- debugger::leash(loose).

Идентификаторы, определенные в Logtalk, аналогичны тем, которые определены в
некоторых компиляторах Prolog:

| ``none``
|    ``[]``
| ``loose``
|    ``[fact, rule, call]``
| ``half``
|    ``[fact, rule, call, redo]``
| ``tight``
|    ``[fact, rule, call, redo, fail, exception]``
| ``full``
|    ``[fact, rule, call, exit, redo, fail, exception]``

По умолчанию отладчик приостанавливается на каждом порту для взаимодействия с пользователем.

Определение точек слежения
--------------------------

Точки слежки Logtalk задаются, указывая перечень предикатов, которые
следует отслеживать, т.е. аналогично большинству отладчиков Prolog. Точки задаются номерами строк в файлах исходного кода предикатов, или указав контекст активации точки слежки. При использовании точек слежения по номером строки (точки останова), номера строки
должны соответствовать первой строке предиката. Чтобы упростить определение точек отслеживания по номерам строки, точки останова задаются с использованием идентификатора объекта вместо имени файла (поскольку все объекты совместно используют одно пространство имен, объект может быть определен только в одном файле).

Определение номеров строк и точек слежения за предикатами
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Номера строк и точки слежения за предикатом задаются при помощи предиката отладчика ``spy/1``. Аргументом выступает точка останова (выраженная в виде пары
``Сущность-строка``), индикатор предиката (``Имя/Арность``) или
список контрольных точек. Например:

.. code-block:: text

   | ?- debugger::spy(person-42).

   Spy points set.
   yes

   | ?- debugger::spy(foo/2).

   Spy points set.
   yes

   | ?- debugger::spy([foo/4, bar/1]).

   Spy points set.
   yes

Номера строк и контрольные точки предиката удаляются при помощи предиката
отладчика `nospy/1`. Аргумент - это или точка слежения, или список точек слежения, или свободная переменная, в последнем случае все точки слежения будут удалены. Например:

.. code-block:: text

   | ?- debugger::nospy(_).

   Все соответствующие точки слежения предиката удалены.
   yes

В точках останова номер строки должен соответствовать первой фразе предиката, за которым мы хотим следить. Но обратите внимание, что не все реализации Prolog предоставляют точный источник номеров строк термов в файле. В документации к инструменту :doc:`../devtools/debugger` есть подробная информация по этому вопросу.

Определение контекстных точек слежения
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Контекстная точка слежения - это кортеж, описывающий контекст исполнения сообщения и цель:

::

   (Sender, This, Self, Goal)

Отладчик вызывается всякий раз, когда цель точки отслеживания и указанный контекст выполнения совпадает с целью, выполняемой в данный момент, и контекстом ее
выполнения. Пользователь может установить любое количество контекстных точек отслеживания по мере необходимости. Например, чтобы входить в отладчик всякий раз, когда вызывается предикат, определенный для объекта с именем ``foo``, можно определить следующую точку отслеживания:

.. code-block:: text

   | ?- debugger::spy(_, foo, _, _).

   Spy point set.
   yes

Можно шпионить за всеми вызовами предиката ``foo/2`` с атомом ``bar`` во втором аргументе, задав условие:

.. code-block:: text

   | ?- debugger::spy(_, _, _, foo(_, bar)).

   Spy point set.
   yes

Предикат отладчика ``nospy/4`` используется для удаления всех подходящих к параметрам запроса точек отслеживания. Например, вызов:

.. code-block:: text

   | ?- debugger::nospy(_, _, foo, _).

   All matching context spy points removed.
   yes

удалит все контекстные точки ослеживания, где значение :term:`self` соответствует
атому ``foo``.

Удаление всех точек отслеживания
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Можно удалить все номера строк, предикаты и контекстные точки отслеживания,
используя предикат отладчика `nospyall/0`.:

.. code-block:: text

   | ?- debugger::nospyall.

   All line number spy points removed.
   All predicate spy points removed.
   All context spy points removed.
   yes

.. _programming_trace:

Трассировка исполняющейся программы
-----------------------------------

Logtalk позволяет отслеживать исполнение для всех объектов, скомпилированных в
режиме отладки. Чтобы запустить отладчик в режиме трассировки, напишите:

.. code-block:: text

   | ?- debugger::trace.

   yes

Затем введите запрос, который необходимо отладить. Для примеров, используя пример ``family`` в дистрибутиве Logtalk:

.. code-block:: text

   | ?- addams::sister(Sister, Sibling).
        Call: (1) sister(_1082,_1104) ? 
        Rule: (1) sister(_1082,_1104) ? 
        Call: (2) ::female(_1082) ? 
        Call: (3) female(_1082) ? 
        Fact: (3) female(morticia) ? 
       *Exit: (3) female(morticia) ? 
       *Exit: (2) ::female(morticia) ? 
       ...

Во время трассировки отладчик будет делать паузу для ввода данных пользователю на каждом порту, печатая информационное сообщение. Каждая строка трассировки начинается с названия порта, за ним следует номер вызова цели и сама цель. Номера вызовов уникальны и позволяют нам группировать порты, используемые для трассировки цели.
В примере выше видно что цель ``::female(_1082)`` удовлетворяется с ответом ``::female(morticia)``. Отладчик также предоставляет информацию о потенциальном количестве решений (детерминизме), добавляя к порту `exit` символ `*`, когда вызов выполняется успешно, но есть еще потенциальные точками выбора, тем самым указывая, могут быть и альтернативные решения.

Обратите внимание, что в режиме трассировки точки отслеживания игнорируются. Если для текущего предложения или цели установлена точка отслеживания, отладчик напечатает символ `#` перед номером порта для шпионских точек, определенных номером  строки, и символ `+` для точек по имени предиката и символ `*` для контекстных точек. Например:

.. code-block:: text

   | ?- debugger::spy(female/2).

   yes

   | ?- addams::sister(Sister, Sibling).
        Call: (1) sister(_1078,_1100) ? 
        Rule: (1) sister(_1078,_1100) ? 
        Call: (2) ::female(_1078) ? 
     +  Call: (3) female(_1078) ? 

Чтобы остановить трассировку и выключить отладчик напишите:

.. code-block:: text

   | ?- debugger::notrace.

   yes

.. _debugging_debug:

Отладка с использованием точек отслеживания
-------------------------------------------

Трассировка выполнения программы генерирует большие объемы отладочных данных. Отладка с использованием контрольных точек позволяет пользователю сконцентрироваться на определенных точках кода. Чтобы начать сеанс отладки с использованием точек отслеживания, напишите:

.. code-block:: text

   | ?- debugger::debug.

   yes

Например, пусть установлена точка отслеживания для предиката ``female/1`` из предыдущего примера:

.. code-block:: text

   | ?- addams::sister(Sister, Sibling).
     +  Call: (3) female(_1078) ? 

Чтобы остановить отладчик, напишите:

::

   | ?- debugger::nodebug.

   yes

Обратите внимание, что остановка отладчика не удаляет точки отслеживания.

.. _debugging_commands:

Команды отладчика
-----------------

Отладчик приостанавливает работу на привязанных портах в режиме трассировки или при достижении точки отслеживания (включая контекстные) и переходит в режим взаимодействия с пользователем. Доступны следующие команды:

``c`` — creep
   продолжить; в качестве альтернативы можно использовать клавиши пробела, Return и Enter
`l` — leap
   продолжает выполнение до тех пор, пока не будет найдена следующая точка слежения
``s`` — skip
   пропускает отладку для текущей цели; действителен на портах call, redo и 
   портах унификации
``q`` — quasi-skip
   пропускает отладку до тех пор, пока не вернется к текущей цели или не достигнет точку слежения
   ; действителен в портах call и redo
``r`` — retry
   перезапускает текущую цель, побочные эффекты при этом не отменяются; действителен на
   порту fail
``j`` — jump
   считывает номер вызова и продолжает выполнение до тех пор, пока порт не будет
   достигнут этот номер
`z` — zap
   считывает либо имя порта, и продолжает выполнение до тех пор, пока этот порт не будет
   достигнут, либо считывает имя игнорируемого порта и продолжает выполнение до тех пор, пока какой-либо порт,
   отличный от заданного, не будет достигнут
``i`` — ignore
   игнорирует цель, предполагая, что она выполнена успешно; действительна на портах call и redo
``f`` — fail
   принудительный бэктрекинг; также может использоваться для преобразования исключения в
   неудачу
``n`` — nodebug
   отключает отладку
``@`` — command; ``!`` можно использовать как альтернативу
   считывает и запускает запрос
``b`` — break
   приостанавливает выполнение и запускает новый интерпретатор; терм `end_of_file`, введенный в командной строке,
   останавливает интерпретатор
``a`` — abort
   вернутся в основной интерпретатор
``Q`` — quit
   выходит их Logtalk
``p`` — print
   печатает текущую цель, используя предикат ``print/1``, если таковой имеется
``d`` — display
   печатает текущую цель без использования операторной нотации
``w`` — write
   печатает текущую цель, при необходимости обрамляя кавычками атомы
``$`` — dollar
   выводит скомпилированную форму текущей цели (для низкоуровневой отладки)
``x`` — contextтg
   пеатает контекст исполнения
``.`` — file
   выводит информацию о файле, сущности (объекте), предикате и номере строки на
   порту унификации
``e`` — exception
   выводит данные исключения, сгенерированное текущей целью
``=`` — debugging
   печатает информацию отладчика
``<`` — write depth
   устанавливат глубину представления терма при распечатке (``0`` устанавливает значение по умолчанию)
``*`` — add
   устанавливает контектную точку отслеживания на текущую цель
``/`` — remove
   удаляет контекстную точку отслеживания с текущей цели
``+`` — add
   устанавливает точку слежения за предикатом на текущую цель
``-`` — remove
   удаляет точку слежения за предикатом для текущей цели
``#`` — add
   устанавливат точку слежения, определенную номером строки, для текущей фразы
``|`` — remove
   удаляет точку слежения, определенную номером строки, для текущей фразы
``h`` — condensed help
   печатает список команд отладчика
``?`` — extended help
   выводит список команд отладчика с пояснениями

.. _debugging_term_write:

Настройка печати термов
-----------------------

Отладка сложных приложений часто требует настройки отображения термов.
Доступные настройки ограничивают глубину печати больших составных
термов и задают параметры традиционному предикату ``portray/1``, указывая как должен быть распечатан терм при использовании команды ``p`` на привязанном порту.

.. _debugging_term_write_depth:

Глубина терма при распечатке
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Термы, распечатываемые отладчиком, могут быть довольно большими. Как описано в предыдущем разделе, отладчик имеет команду ``<`` для установки максимальной глубины печати составных терминов. Эта команда требует, чтобы используемый
:term:`backend Prolog compiler` поддерживал нестандартный, но распространенный
параметр ``max_depth/1`` для предиката `write_term/3`. Когда выводимый на экран составной терм глубоко вложен, вложенные термины печатаются только до указанной глубины, а пропущенные вложенные термины обычно заменяются на `...". Например:

::

   | ?- write_term([0,1,2,3,4,5,6,7,8,9], [max_depth(5)]).
   
   [0,1,2,3,4|...]
   yes

Максимальная глубина по умолчанию зависит от Prolog-интерпретатора. Чтобы печатать составные термы без ограничения глубины, установите глубину равной нулю.

.. _debugging_custom_term_writing:

Настройка пользовательского режима печати термов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Неявное использование традиционного предиката ``print/1`` (команда ``p`` отладчика) или предиката ``portray/1``, определяемого пользователем, требуют поддержки этих предикатов используемым компилятором Prolog. Ознакомтесь с документацией по используемому интерпретатору. Пусть задано в качестве примера следующее определение ``portray/1``:

::

   portray(e(V1,V2)) :-
       format('~q ---> ~q~n', [V1,V2]).

Вызов предикат ``print/1`` с параметром ``e(x1,x7)`` (сложный терм) в качестве аргумента выдаст:

.. code-block:: text

   | ?- print(e(x1,x7)).

   x1 ---> x7
   yes

.. _debugging_context:

Вызовы с переключением контекста
--------------------------------

Logtalk предоставляет управляющую конструкцию :ref:`control_context_switch_2`,
которая позволяет выполнять запрос в контексте объекта.
Обычная отладка включает проверку локальных предикатов объекта (например, предикатов, представляющих внутреннее динамическое состояние) и отправку сообщения
изнутри объекта. Эта управляющая конструкция также может быть использована для написания
тестов модулей.

Рассмотрим следующий игрушечный пример:

::

   :- object(broken).

       :- public(a/1).

       a(A) :- b(A, B), c(B).
       b(1, 2). b(2, 4). b(3, 6).
       c(3).

   :- end_object.

Что-то не так, когда пытаемся использовать ``public`` предикат объекта ``a/1``:

.. code-block:: text

   | ?- broken::a(A).

   no

Чтобы продиагностировать проблему, вместо компиляции объекта в режиме отладки и выполнения трассировки запроса для проверки предложений на наличие не-``public``-предикатов, мы можем вместо этого просто ввести:

.. code-block:: text

   | ?- broken << c(C).

   C = 3
   yes

Управляющая структура ``(<<)/2`` переключает контекст исполнения на объект в левом аргументе, затем компилирует и запускает правый аргумент в этом контексте:

.. code-block:: text

   | ?- broken << (self(Self), sender(Sender), this(This)).

   Self = broken
   Sender = broken
   This = broken

   yes

Как показано на примере выше, управляющая конструкция ``(<<)/2`` позволяет вызывать
локальные и ``private``-предикаты объекта. Однако важно подчеркнуть, что мы не обходим или не бореся с директивами области видимости предиката объекта. Вызовы выполняются в контексте указанного объекта, а не в контексте объекта, выполняющего вызов ``(<<)/2``.
Таким образом, управляющая конструкция ``(<<)/2`` реализует форму
*переключение контекста исполнения*.

Наличие ``(<<)/2`` управляется флагом компилятора :ref:`context_switching_calls <flag_context_switching_calls>` (его значение по умолчанию определено в файлах адаптера интерпретатора Prolog).

.. _debugging_messages:

Отладочные сообщения
--------------------

Вызов предиката :ref:`logtalk::print_message/3 <methods_print_message_3>`, в котором указывается тип сообщения - `debug` либо `debug(Group)`, по умолчанию производит печать только тогда, когда флаг :ref:`debug <flag_debug>` включен. Более того, эти вызовы подавляются компилятором, когда
включен флаг :ref:`optimize <flag_optimize>`. Обратите внимание, что печать отладочных сообщений не требует компиляции кода в режиме отладки, достаточно включить флаг ``debug``.

Мета-сообщения
~~~~~~~~~~~~~~

Чтобы избежать необходимость определять грамматические правила :ref:`methods_message_tokens_2` для перевода каждого сообщения отладки, Logtalk предоставляет токенизацию по умолчанию для пяти *мета-сообщений*, которые представляют собой наиболее распространенные случаи:

``@Message``
   По умолчанию сообщение печатается в том виде, в каком оно было передано в предикат ``write/1``,
   за которым следует перевод строки.
``Key-Value``
   По умолчанию сообщение печатается как ``Ключ: Значение``, за которым следует
   новая строка. Ключ печатается так, как печатает предикат ``write/1``,
   а значение печатается по правилам предиката ``writeq/1``.
``Format+Arguments``
   По умолчанию сообщение печатается в том виде, в каком оно было передано в предикат ``format/2``.
    
``List``
   По умолчанию элементы списка печатаются с отступом по одному в строке.  
   Перед элементами ставится тире, и они могут быть отображены согласно сообщениям `@Message`, `Ключ-значение`
   или ``Format+Arguments``. Если это не так, то элемент
   печатается по правилам предиката ``writeq/1``.
``Title::List``
   По умолчанию печатается заголовок, за которым следует новая строка и
   элементы списка с отступом, по одному на строку. Элементы печатаются так, как в
   мета-сообщении ``List``.

Несколько простых примеров использования мета-сообщений:

.. code-block:: text

   | ?- logtalk::print_message(debug, core, @'Phase 1 completed').
   yes

   | ?- set_logtalk_flag(debug, on).
   yes

   | ?- logtalk::print_message(debug, core, @'Phase 1 completed').
   >>> Phase 1 completed
   yes

   | ?- logtalk::print_message(debug, core, answer-42).
   >>> answer: 42
   yes

   | ?- logtalk::print_message(debug, core, 'Position: <~d,~d>'+[42,23]).
   >>> Position: <42,23>
   yes

   | ?- logtalk::print_message(debug, core, [arthur,ford,marvin]).
   >>> - arthur
   >>> - ford
   >>> - marvin
   yes

   | ?- logtalk::print_message(debug, core, names::[arthur,ford,marvin]).
   >>> names:
   >>> - arthur
   >>> - ford
   >>> - marvin
   yes

Префикс ``>>>`` - это префикс сообщения по умолчанию для ``debug``-сообщений.
Его можно переопределить с помощью hook-предиката :ref:`logtalk::message_prefix_stream/4 <methods_message_prefix_stream_4>`. Например:

::

   :- multifile(logtalk::message_prefix_stream/4).
   :- dynamic(logtalk::message_prefix_stream/4).

   logtalk::message_prefix_stream(debug, core, '(dbg) ', user_error).

Выборочная печать отладочных сообщений
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

По умолчанию все сообщения отладки либо печатаются, либо пропускаются, в зависимости от флагов :ref:`debug <flag_debug>` и :ref:`optimize <flag_optimize>`. Когда код не компилируется в оптимальном режиме, инструмент :doc:``../devtools/debug_messages`` позволяет выборочно включать отладочные сообщения для каждого :term:``component`` и для каждой группы отладки. Например, чтобы включить все ``debug``- и ``debug(Group)``-сообщения для компонента ``parser``:

.. code-block:: text

   % при загрузке инструмента все сообщения по умолчанию отключены: 
   | ?- logtalk_load(debug_messages(loader)).
   ...

   % включить как debug-, так и debug(_)-сообщения:
   | ?- debug_messages::enable(parser).
   yes

Чтобы включить только сообщения ``debug(tokenization)`` для компонента ``parser``:

.. code-block:: text

   % сначала отключить все сообщения:
   | ?- debug_messages::disable(parser).
   yes

   % включить только сообщения debug(tokenization):
   | ?- debug_messages::enable(parser, tokenization).
   yes

Более подробную информацию смотрите в документации по инструменту. 

.. _debugging_hooks:

Использование механизма расширения терма для отладки
------------------------------------------------------

Отладочные сообщения выводят только информацию, заданную настройками по умолчанию. Однако эти сообщения могут быть перехвачены для выполнения других действий. Альтернативой является использование вместо этого механизма расширения терма :ref:`` <expansion_expansion>`` для условной компиляции целей отладки. Например :doc:`../libraries/hook_objects` предоставляет объект
:ref:`print_goal_hook <apis:print_goal_hook/0>`, упрощающий распечатку целлей до и после их вызова путем простого добавления префикса некоторым оператором. Подробности в документации по библиотеке и объекту hook.
Вы также можете определить свои собственные специализированные объекты hook для пользовательских задач отладки.

.. _debugging_ports_profiling:

Профилирование портов
---------------------

Дистрибутив Logtalk включает в себя инструмент :doc:`../devtools/ports_profiler`, основанный на той же модели процедурного ящика, описанной выше. Этот инструмент особенно полезен для отладки проблем с производительностью (например, из-за отсутствия детерминизма или неожиданного бектрекинга). Ищите описание в документации по инструменту. 

.. _debugging_events:

События отладки и отслеживания
------------------------------

Интерфейс прикладного программирования (API) определяет два многофайловых предиката,
:ref:`logtalk::trace_event/2 <apis:logtalk/0::trace_event/2>` и
:ref:`logtalk::debug_handler/2 <apis:logtalk/0::debug_handler/2>` для обработки событий трассировки и отладки. Он также включает мультифайловй предикат :ref:`logtalk::debug_handler_provider/1 <apis:logtalk/0::debug_handler_provider/1>`, позволяющий объекту (или категории) декларировать себя в качестве обработчика событий отладчика. Инструменты Logtalk ``debugger`` и ``ports_profiler`` являются обычными приложениями, которые реализуются с использованием этого API. Он также может быть использован для реализации альтернативных или новых инструментов отладки.
Ознакомьтесь с документацией API, почитайте исходный код инструментов ``debugger`` и ``ports_profiler``.
