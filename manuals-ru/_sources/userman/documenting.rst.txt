..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Если это не требуется законодательством или не согласовано в письменной форме, программное обеспечение
   распространяется по лицензии на условиях "КАК ЕСТЬ".,
   БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых.
   См. лицензию для конкретного языка, регулирующего разрешения и
   ограничения, предусмотренные Лицензией.


.. _documenting_documenting:

Документирование
================

Если флаг :ref:`source_data <flag_source_data>` включен, то
компилятор сохраняет всю соответствующую документирующую информацию, собранную при компиляции исходного файла. Программа :doc:`../devtools/lgtdoc` организует доступ к этой информации, используя ref:`reflection <reflection_reflection>`, она генерирует файл документации для каждой скомпилированной сущности (объекта, протокола или категории) в формате XML. Содержимое XML-файла включает имя объекта, тип и режим компиляции (статический или динамический), отношения объекта с другими объектами и описание любых объявленных предикатов (имя, режим компиляции, область видимости, ...). Файлы документации XML можно дополнить произвольной пользовательской информацией, о самой сущности, ее предикатах при помощи двух директив, описанных в следующем разделе. Программа `lgtdoc` включает в себя сценарии POSIX и Windows для преобразования
файлов документации XML в несколько конечных форматов (таких как HTML и PDF).

.. _documenting_directives:

Директивы документирования
--------------------------

Logtalk предоставляет две директивы документирования для удобного предоставления произвольной информации о сущности или предикате. Эти директивы дополняют другие директивы, они позволяют задавать дополнительную информацию в документации: :ref:'directives_mode_2' и :ref:'directives_meta_predicate_1'.

.. _documenting_entity:

Директивы для сущностей
~~~~~~~~~~~~~~~~~~~~~~~

Произвольная информация для пользователя о сущности представляется при помощи директивы :ref:`directives_info_1`:

::

   :- info([
       Key1 is Value1,
       Key2 is Value2,
       ...
   ]).

В этом шаблоне ключи должны быть атомами, а значения - основными терминами.
Определены следующие ключи, распознаваемые инструментами Logtalk:

``comment``
   Комментарий, описывающий назначение сущности (атом). В качестве руководства по стилю оформления,
   не используйте слишком длинные комментарии. Если вам нужно предоставить дополнительные
   подробности, используйте ключ ``remarks``.
``author``
   Автор(ы) сущности (атом или составной термин ``{entity}``, где
   ''entity'' — имя XML-сущности в определяемом пользователем
   файле ``custom.ent``).
``version``
   Номер версии (составной терм ``Major:Minor:Patch``), следование
   `Рекомендации по семантическому управлению версиями <https://semver.org>`_ настоятельно рекомендуется.
``date``
   Дата последнего изменения в стандартном формате ISO 8601 (``Year-Month-Day``,
   где ``Year``, ``Month`` и ``Day`` - целые числа).
``parameters``
   Имена параметров и описания параметризованных объектов (список
   пар ``Name-Description``, где и имя и описание - атомы).
``parnames``
   Имена параметров для параметризованных объектов (список атомов; более простой
   версия предыдущего ключа, используемого при описаниях параметров
   считается ненужным).
``copyright``
   Уведомление об авторских правах на исходный код объекта (атом или сложный
   терм ``{entity}``, где ``entity`` - название сущности XML,
   определенный в пользовательском файле ``custom.ent``).
``license``
   Условия лицензии на исходный код сущности; как правило, только наименование лицензии
   (атом или составной термин ``{entity}``, где ``entity`` - это
   имя XML-объекта в пользовательском файле `custom.ent`).
``remarks``
   Список общих замечаний о сущности, используются пары ``Topic-Text``
   где и тема, и текст должны быть атомами.
``see_also``
   Список связанных сущностей, используются идентификаторы сущностей, которые могут
   быть атомами или составными термами).

Например:

::

   :- info([
       version is 2:1:0,
       author is 'Paulo Moura',
       date is 2000-11-20,
       comment is 'Building representation.',
       diagram is 'UML Class Diagram #312'
   ]).

Используйте только те ключевые слова, которые имеют смысл в предметной области приложения, также вы можете придумывать свои собственные ключевые слова. Все пары ``ключ-значение`` доступны программно при помощи :ref:`reflection API <reflection_reflection>` и видны инструменту :doc:`../devtools/lgtdoc` (который включает их в сгенерированную документацию).

.. _documenting_predicate:

Директивы предикатов
~~~~~~~~~~~~~~~~~~~~

Произвольная информация о предикате, задаваемая пользователем, представляется с помощью директивы :ref:`directives_info_2`:

::

   :- info(Name/Arity, [
       Key1 is Value1,
       Key2 is Value2,
       ...
   ]).

Первым аргументом может быть также нетерминальный символ правила формальной грамматики, ``Имя/Арность``. Ключи должны быть атомами, а значения - основными терминами.
Определены следующие ключи, распознаваемые инструментами Logtalk:

``comment``
   Комментарий, описывающий предикат (или нетерминальный символ) назначение (атом).
   Стиль оформления здесь не допускает слишком длинных комментариев. Если вам нужно
   оформлять дополнительную информацию при помощи ключа ``remarks``.
``arguments``
   Имена и описания аргументов предикатов для "красивого" вывода на печать
   (список пар ``Name-Description``, где и имя и описание
   являются атомами).
``argnames``
   Имена аргументов предикатов для "красивой" печати (список
   атомов; более простая версия предыдущего ключа, используемая если описания аргументов
   считаются ненужными).
``allocation``
   Объекты, в которых надо задавать предикат. Некоторые возможные значения:
   ``container``, ``descendants``, ``instances``, ``classes``,
   ``subclasses`` и ``any``.
``redefinition``
   Описывает, ожидается ли переопределение предиката, и, если да, то 
   каким образом. Возможные значения - ``never``, ``free``,
   ``specialize``, ``call_super_first``, ``call_super_last``.
``exceptions``
   Список возможных исключений, создаваемых предикатом, 
   пары вида ``Description-Exception``. Описание должно быть
   атомом. Терм исключения должен быть основным термом.
``examples``
   Список типичных примеров вызова предиката с использованием формата
   ``Description-Goal-Bindings``. Описание должно быть атомом,
   а цель ``Goal`` должна разделять переменные с ``Bindings``.  
   ткрмы привязки переменных представляются в формате ``{Variable = Term, ...}``.
   Если нет привязок к переменным, успех или неудача
   вызова предиката должна быть представлена терминами ``{yes}``
   или ``{no}``, соответственно.
``remarks``
   Список общих замечаний о предикате, используются пары ``Topic-Text``,
   в которых и тема, и текст должны быть атомами.
``see_also``
   Список связанных предикатов и нетерминальных символов (с использованием идентификаторов предиката
   и нетерминальных символов).

Например:

::

   :- info(color/1, [
       comment is 'Таблица предопределенных цветов.',
       argnames is ['Цвет'],
       constraint is 'Можно использовать не более четырех цветов.'
   ]).

Как и в случае с директивой ``info/1``, используйте только те ключевые слова, которые имеют смысл для вашего приложения, и помните, что вы вольны придумывать свои собственные ключевые слова. Все пары ключ-значение извлекаются программным способом при помощи :ref:`reflection API <reflection_reflection>` и видны утилите :doc:`../devtools/lgtdoc`, формирующую из этих пар документацию.

.. _documenting_exceptions:

Документирование исключений, порождаемых предикатами
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как описано выше, директива предиката ``info/2`` поддерживает ключ ``exceptions``, позволяющий перечислять все исключения, возникающие при вызове предиката. Например:

::

   :- info(check_option/1, [
       comment is 'Успешно выполняется, если параметр верен. Порождает ошибку в противном случае.',
       argnames is ['Параметр'],
       exceptions is [
           '``Параметр`` - переменная' - instantiation_error,
           '``Параметр`` не является ни переменной, ни сложным термом' - type_error(compound, 'Параметр'),
           '``Параметр`` - слодный терм, но значение вне допустимого диапазона' - domain_error(значение, 'Параметр')
       ]
   ]).

По возможности следует использовать только стандартные исключения. Полный список стандартных исключений находится в разделе :ref:`error handling methods <error_handling_methods>`. Имена аргументов должны совпадать с теми, которые указаны в ключах ``arguments`` и ``argnames``. Исключения обычно перечисляются, начиная с ошибок создания и удаления экземпляра, затем идут ошибки типа, за ними - ошибки области значений.

Для каждого исключения используйте *controlled ldnguage*, как указано, например, в базовом стандарте ISO Prolog, в данном руководстве мы также рекомендуем следовать этому стандарту. Примеры:

Ошибка конкретизации: один из нескольких аргументов не может быть переменной
   ``Argument`` is a variable
   
   ``Argument1`` and ``Argument2`` are variables

Ошибка конкретизации: требуется закрытый список со связанными элементами
   ``Argument`` is a partial list or a list with an element ``Element`` which is a variable

Ошибка неправильной конкретизации: аргумент не является переменной
   ``Argument`` is not a variable

Ошибка типа: аргумент не является переменной, но также и не имеет ожидаемого типа
   ``Argument`` is neither a variable nor a TYPE

   ``Argument`` is neither a partial list nor a list

Ошибка типа: элемент списка не является переменной, но не имеет ожидаемого типа
   An element ``Element`` of the ``Argument`` list is neither a variable nor a TYPE

Ошибка области значений (определения): аргумент имеет правильный тип, но не в ожидаемом диапазоне значений
   ``Argument`` is a TYPE but not a valid DOMAIN

   ``Argument`` is an integer that is less than zero

Ошибка области значений (определения): элемент списка соответствует ожидаемому типу, но не находится в требуемом диапазоне
   An element ``Element`` of the ``Argument`` list is a TYPE but not a valid DOMAIN

Другие классы ошибок можно выводить в менее формализованном стиле. В случае сомнений, посмотрите примеры в этом руководстве, в документации по API и
документацию по стандарту ISO Prolog.

.. _documenting_processing:

Обработка и просмотр файлов документации
----------------------------------------

Программа :doc:`../devtools/lgtdoc` порождает XML-файл документации для каждой сущности программы по отдельности. Она также генерирует справочники-индексы по библиотекам, каталогам, сущностям и предикатам в процессе обработки директив документирования. Например, предполагая, что программа реализована в файлах со стандартными расширениями, объект ``trace`` и его параметрический "собрат" ``sort(_)`` будут отдокументированы в XML-файлах ``trace_0.xml`` и ``sort_1.xml``.

Каждый XML-файл сущности содержит ссылки на два других файла, XML-файл спецификации и файл таблицы стилей XSLT. Файл спецификации XML - это либо файл DTD (`logtalk_entity.dtd`), либо
файл схемы XML (`logtalk_entity.xsd`). Файл таблицы стилей XSLT отвечает за преобразование XML-файлов в некоторый целевой формат, такой как HTML или PDF.
Имена по умолчанию для файла спецификации XML и таблицы стилей XSL
определяется утилитой :doc:`../devtools/lgtdoc`, но могут быть
переопределены путем передачи списка параметров к предикатам утилиты. Подкаталог ``lgtdoc/xml`` в каталоге установки Logtalk содержит файлы спецификаций XML, описанные выше, вместе с несколькими примерами XSL-файлов, а также образцы скриптов для преобразования XML-документации в другие форматы, в частности, reStructuredText, Markdown, HTML и PDF. Например, предположим, что вы хотите сгенерировать документацию API для библиотеки ``types``:

.. code-block:: text

   | ?- {types(loader)}.
   ....

   | ?- {lgtdoc(loader)}.
   ....

   | ?- lgtdoc::library(types).
   ...

Вышеперечисленные запросы создадут ``xml_docs`` в вашем текущем каталоге. Предположим, что мы хотим сгенерировать документацию для системы на основе Sphinx, и что мы используем операционную систему класса POSIX, дальнейшие преобразования выполняются следующим образом:

.. code-block:: bash

   $ cd xml_docs
   $ lgt2rst -s -m

Скрипт ``lgt2rst`` задаст пару вопросов (название проекта, автор, версия, ...). После его завершения сгенерированные HTML-файлы по умолчанию будут находиться в директории ``_build/html``:

.. code-block:: bash

   $ open _build/html/index.html

Для операционных систем Windows созданы сценарии PowerShell (рекомендуется) и JScript (если нет PS). Чтобы сгенерировать документацию в формате HTML, окне PowerShell запускаем:

.. code-block:: text

   cd xml_docs
   lgt2html.ps1 -p saxon

При использовании сценариев JScript, что не рекомендуется ввиду устаревшей технологии, также можно использовать и сценарии `.bat` как последнюю алтернативу:

.. code-block:: text

   cd xml_docs
   lgt2html /p:saxon

После завершения порождения HTML-файлов результат будет в каталоге ``xml_docs``.

См. файл ``NOTES`` в каталоге утилит, там есть более подробная информация, особенно по процессу XSLT-преобразования и необходимым для этого программам. Прилагаемые примеры файлов можно использовать в качестве отправной точки для создания документации ваших приложений Logtalk.

Файл DTD Logtalk-а ``logtalk_entity.dtd`` содержит ссылку на настраиваемый пользователем файл ``custom.ent``, в котором есть декларации XML-объектов для
имен авторов исходного кода, условий лицензии и строки авторских прав. Отредактируйте файл ``custom.ent``: надо внести туда ваши персональные данные, затем модно будет использовать эти XML-сущности в директивах документирования ``info/1``. Например, если XML-объекты поименованы как *author*, *license* и
*copyright*, то можно сокращать теперь следующим образом уже известные нам декларации:

::

   :- info([
       version is 1:1:0,
       author is {author},
       license is {license},
       copyright is {copyright}
   ]).

Ссылки на объекты заменяются значением соответствующей XML-сущностью в процессе обработки XML-файлов документации, а **не в процессе** создания XML-файла документации; такой формат обозначения - просто сокращение, обрабатываемое в рамках технологий XML.

Утилита :doc:`../devtools/lgtdoc` распознает набор параметров, управляющих созданием XML-файлов документации. Для получения подробной информации - документация по этой утилите. Есть также утилита :doc:`../devtools/doclet`, позволяющая автоматизировать шаги, необходимые для создания документации приложения.

.. _documenting_formatting:

Использование разметки в тексте документации
--------------------------------------------

Дополнительная разметка текста, например комментариев в документации, выполняется в соответствии с синтаксисом Markdown или reStructuredText. В этих форматах можно получить и целевой текст документации из XML-файлов. Тексты в Markdown и reStructuredText затем можно преобразовать в формат HTML, ePub и PDF. Обратите внимание, что синтаксических элементов Markdown и reStructuredText
достаточно для решения большинства задач разметки документов API:

.. code-block:: text

   Размечайте *курсивный текст* одной звездочкой.
   Размечайте **жирный текст** двумя звездочками.
   Размечайте ``моноширинный текст`` двумя обратными кавычками.

Рендеринг этого блока в виде разметки дает:

   Размечайте *курсивный текст* одной звездочкой. Размечайте **жирным шрифтом** с помощью
   двух звездочек. Размечайте ``моноширинный текст`` двумя обратными кавычками.

Диаграммы
---------

Инструмент :doc:`../devtools/diagrams` поддерживает широкий спектр диаграмм, применимые в документировании приложения. Сгенерированные диаграммы могут включать URL-ссылки как на исходный код, так и на документацию по API. Их можно связывать, соединяя, например, диаграммы абстрактного уровня с более подробными диаграммами.
Эти функции позволяют диаграммам быть эффективным решением для навигации и
понимания структуры и реализации приложения. Этот инструмент использует тот же :ref:`reflection API <reflection_reflection>` как и ``lgtdoc``, он имеет доступ к тем же исходным данным. Для детального ознакомления с инструментом ознакомьтесь с его документацией. 
