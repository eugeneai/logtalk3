..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Если это не требуется законодательством или не согласовано в письменной форме, программное обеспечение
   распространяется по лицензии на условиях "КАК ЕСТЬ".,
   БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых.
   См. лицензию для конкретного языка, регулирующего разрешения и
   ограничения, предусмотренные Лицензией.


.. _events_events:

Программирование, основанное на событиях
========================================

Добавление возможностей программирования, управляемого событиями, к
языку Logtalk [Moura94]_ основано на простой, но мощной идее:

   Вычисления должны быть результатом не только отправки сообщений, но и
   **наблюдений** за сообщениями.

Необходимость увязки вычислений с возникающими событиями была очень
рано признана важной в языках представления знаний, языках программирования
[Stefik_et_al_86]_, [Moon86]_, в операционных системах [Tanenbaum87]_ и
графических пользовательских интерфейсах.

Благодаря интеграции объектно-ориентированного и событийно-ориентированного
программирования можно достичь следующих целей:

*  Сведите к минимуму *зацепления* между объектами. Объект должен содержать только то,
   для чего он предназначен. Если объект наблюдает (observes) за другим объектом, это
   означает, что он зависит только от public-протокола
   объекта, за которым наблюдают, но не от реализации этого протокола.

*  Реализовать механизм для построения *рефлексивных систем* в Logtalk на основе
   динамического поведения объектов в дополнение к рефлексивной
   информации о предикатах и связях объекта.

*  Обеспечить механизм для простого определения *пре- и
   постусловий* метода, которые можно отключать с помощью флагов компилятора :ref:`events <flag_events>`
     Пред- и постусловия могут быть определены в одном и том же
   объекте, содержащем эти методы, или распределены между несколькими объектами-наблюдателями.
    

*  Реализовать механизм *публикация-подписка* (*publish-subscribe*), где public-сообщения играют
   роль событий.

.. _events_definitions:

Определения
-----------

Слова *event* (*event*) и *monitor* (*monitor*) имеют несколько значений в информатике. Чтобы избежать недоразумений, определим их в контексте Logtalk.

.. _events_event:

Событие
~~~~~~~

В объектно-ориентированной системе все вычисления начинаются с отправки сообщений. Таким образом, вполне естественно предположить, что единственным видом события, которое может произойти в такого рода системах, является именно отправка
сообщения. Событие представляется упорядоченным кортежем ``(Объект, Сообщение, Отправитель)`` (``(Object, Message, Sender)``).

Если рассматривать обработку сообщения неделимым актом, то отправка сообщения и возврат управления вызвавшему объекту представляются в виде двух отдельных событий. Такое разделение позволяет более детально управлять динамическим поведением системы. В Logtalk эти два типа событий называются ``before`` и ``after``, одно обозначает отправку сообщения, а другое -- возврат управления отправителю. Поэтому немного усовершенствуем наше представление событий -- создадим кортеж вида ``(Событие, Объект, Сообщение, Отправитель)`` (``(Event, Object, Message, Sender)``).

Реализация событий в Logtalk обладает следующими свойствами:

Независимость между этими двумя типами событий
   Можно использовать только один тип события или обработать каждое из
   событий независимо.

Все события автоматически генерируются механизмом отправки сообщений
   Порождение событий прозрачно реализуется
   механизмом отправки сообщений. Пользователю необходимо только определить
   отслеживаемые события.

Режим наблюдения за событием в любой момент может быть динамически изменен во время выполнения программы
   Механизм событий позволяет пользователю не только 
   наблюдать, но и контролировать, изменять поведение приложения,
   в частности, путем динамического изменения наблюдаемых событий во время
   выполнения программы Наша цель - предоставить пользователю
   возможность моделирования наибольшего количества ситуаций.

.. _events_monitor:

Монитор
~~~~~~~

Противоположным событию является понятие монитора. Монитор - это объект, который автоматически уведомляется механизмом отправки сообщений всякий раз, когда происходит зарегистрированное событие. Любой объект, определяющий предикаты обработки событий, может играть роль монитора.

Реализация мониторов в Logtalk обладает следующими свойствами:

В качестве монитора может выступать любой объект
   В роли монитора может быть любой объект во время своего
   существования. Минимально необходимый протокол объектов-наблюдателей - это 
   протокол :ref:`monitoring <apis:monitoring/0>`. Строго говоря,
   ссылка на этот протокол необходима только при специализации обработчиков событий.
   Тем не менее, считается хорошей практикой программирования всегда
   использовать этот протокол при определении обработчиков событий.

Неограниченное количество мониторов для каждого события
   Несколько мониторов могут наблюдать за одним и тем же событием по разным
   причинам. Таким образом, количество мониторов на событие ограничено только
   имеющимися вычислительными ресурсам.

Состояние монитора объекта может быть динамически изменено во время выполнения программы
   Механизм мониторинга не требует, чтобы объект был обязательно динамическим
   (состояние монитора не сохраняется в
   объекте).

Обработчики событий не могу изменять аргументы события
   Примечательно, что если сообщение содержит свободные переменные, они не могут быть
   связаны с каким-либо значением в обработчике событий.

.. _events_generation:

Генерация событий
-----------------

Предполагая, что флаг :ref:`events <flag_events>` установлен на ``allow`` (разрешить) для объекта (или категории), отправляющего сообщения, и за которым мы хотим наблюдать, для каждого сообщения, отправленного с использованием управляющей конструкции :ref:`control_send_to_object_2` система выполнения автоматически генерирует два события.
Первый — *before event* — генерируется при отправке сообщения. 
Второе — *after event* — генерируется после успешного выполнения сообщения.

Обратите внимание, что *self*-сообщения (с помощью конструкции :ref:`control_send_to_self_1`) и *super*-вызовы (с помощью конструкции :ref:`control_call_super_1`) не генерируют события.

.. _events_communicating:

Передача событий мониторам
--------------------------

Всякий раз, когда происходит отслеживаемое событие, механизм отправки сообщений вызывает все зарегистрированные обработчики всех зарегистрированных мониторов. Эти вызовы выполняются на низком уровне в обход обычных механизмов отправки сообщений, чтобы избежать потенциальных бесконечных циклов. Обработчики событий - это реализации для ``public``-предикатов, объявленных во встроенном протоколе :ref:`monitoring <apis:monitoring/0>` (более подробную информацию см. ниже).

.. _events_performance:

Вопросы производительности
--------------------------

В идеале наличие отслеживаемых сообщений не должно влиять на обработку оставшихся сообщений. С другой стороны, для каждого отправленного сообщения система должна проверять, отслеживается ли соответствующее событие. По идее эта проверка должна выполняться за одно и то же время и независимо от количества контролируемых событий. Представление событий использует индекс по первому аргументу, выполняемое большинством компиляторов Prolog, который обеспечивает, в
общем случае, доступ в постоянное время.

Поддержку событий можно отключать у каждого объекта или категории с помощью флага компилятора :ref:`events <flag_events>`. Когда поддержка событий отключена Logtalk использует оптимизированный код для обработки отправки сообщений, т.е. без проверки и отслеживания событий, что приводит к небольшому, но измеримому улучшению производительности.

.. _events_semantics:

Семантика мониторинга
---------------------

Семантика действий монитора заключается в том, что его успешное выполнение дополнительно обуславливает успех выполнения сообщения:

-  Все действия, связанные с событиями типа ``before`` должны быть успешными, 
   чтобы обработка сообщения могла начаться.

-  Все действия, связанные с событиями типа ``after``, также должны
   быть успешными, тогда само сообщение будет успешным. Неуспех любого
   действия, связанного с событием типа ``after`` приводит к бэктрекингу
   исполнения сообщения (отказ монитора никогда не вызывает
   бэктрекинг предыдущих действий монитора).

Обратите внимание, что это самый общий вариант. Если требуется прозрачное присутствие мониторов при обработке сообщений, нужно просто определить его действия таким образом, чтобы они никогда не завершались неудачей (что сделать очень просто).

.. _events_order:

Порядок активации мониторов
---------------------------

В идеале, всякий раз, когда для одного и того же события определено несколько мониторов, порядок вызова не должен влиять на результат. Однако это не всегда возможно. В случае события типа ``before``, отказ монитора предотвращает отправку сообщения и предотвращает выполнение оставшихся мониторов. В случае события типа ``after`` сбой монитора приведет к бэктрекингу выполнения сообщения. Поэтому различный порядок активации монитора может привести к разным результатам, если действия монитора как-то модифицируют объект, такие действия не отменяются в случае бектрекинга. Таким образом, порядок активаций для монитора следует рассматривать как произвольный. По сути, чтобы предположить или попытаться навязать определенную последовательность, требуется глобальное понимание динамики приложения, что не всегда возможно. Кроме того, это понимание может оказаться неверными, если произойдут какие-либо изменения в условиях исполнения. Обратите внимание, что, учитывая независимость между мониторами, не имеет смысла как-то связывать неудачу с бэктрекингом предыдущих действий.

.. _events_handling:

Обработка событий
-----------------

Logtalk предоставляет три встроенных предиката для обработки событий. Эти предикаты поддерживают определение, перечисление и отмену событий.
Приложения, основанные на интенсивном использовании событий, обычно состоят из объектов, которые используют эти встроенные предикаты для реализации комплексного поведения.

.. _events_defining:

Определение новых событий
~~~~~~~~~~~~~~~~~~~~~~~~~

Новые события могут быть определены с помощью встроенного предиката:ref:`predicates_define_events_5`:

.. code-block:: text

   | ?- define_events(Event, Object, Message, Sender, Monitor).

Обратите внимание, что если сто-либо из ``События``, ``Объекта``, ``Сообщения`` и `` Отправитель`` является свободной переменной или содержит свободные переменные, то такой вызов определит **набор** соответсвующих событий.

.. _events_abolishing:

Отмена определенных событий
~~~~~~~~~~~~~~~~~~~~~~~~~~~

События, которые больше не нужно мониторить, отменяются при помощи
встроенного предиката :ref:`predicates_abolish_events_5`:

.. code-block:: text

   | ?- abolish_events(Event, Object, Message, Sender, Monitor).

Если предикат вызывается со свободными переменными, то удалятся все соответсвующие
события.

.. _events_finding:

Поиск определенных событий
~~~~~~~~~~~~~~~~~~~~~~~~~~

События, которые определены в данный момент, могут быть получены с помощью
встроенного предиката :ref:`predicates_current_event_5`:

.. code-block:: text

   | ?- current_event(Event, Object, Message, Sender, Monitor).

Обратите внимание, что этот предикат вернет **наборы** совпадающих событий, если некоторые из аргументов являются свободными переменными или содержат свободные переменные.

.. _events_handlers:

Определение обработчиков событий
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Встроенный протокол :ref:`monitoring <apis:monitoring/0>` декларирует два открытых предиката :ref:`methods_before_3` и :ref:`methods_after_3`, которые
автоматически вызываются для обработки событий ``before`` и ``after``. Любой объект, играющий роль монитора, должен определить один или оба обработчика событий:

::

   before(Object, Message, Sender) :-
       ... .

   after(Object, Message, Sender) :-
       ... .

В аргументы в обоих методов механизм отправки сообщения передает значения, когда происходит контролируемое событие. Например, предположим, что надо определить монитор с именем ``tracer``, который будет отслеживать любое сообщение, отправленное объекту, печатая некоторый текст на стандартный вывод.
Его определение реализуется примерно так:

::

   :- object(tracer,
       % встроенный протокол для методов обработчики событий
       implements(monitoring)).

       before(Object, Message, Sender) :-
           write('call: '), writeq(Object),
           write(' <-- '), writeq(Message),
           write(' from '), writeq(Sender), nl.

       after(Object, Message, Sender) :-
           write('exit: '), writeq(Object),
           write(' <-- '), writeq(Message),
           write(' from '), writeq(Sender), nl.

   :- end_object.

Предположим, что есть следующий объект:

::

   :- object(any).

       :- public(bar/1).
       bar(bar).

       :- public(foo/1).
       foo(foo).

   :- end_object.

После компиляции и загрузки, установки флага :ref:`events<flag_events>` в значение ``allow``, можно начать трассировку каждого сообщения, отправленного любому объекту путем вызова встроенного предиката :ref:`predicates_define_events_5` :

.. code-block:: text

   | ?- set_logtalk_flag(events, allow).

   yes

   | ?- define_events(_, _, _, _, tracer).

   yes

С этого момента каждое сообщение, отправленное от ``user`` любому объекту, будет
отслеживаться на экране:

.. code-block:: text

   | ?- any::bar(X).

   call: any <-- bar(X) from user
   exit: any <-- bar(bar) from user
   X = bar

   yes

Чтобы остановить трассировку, используем встроенный предикат:ref:`predicates_abolish_events_5`:

.. code-block:: text

   | ?- abolish_events(_, _, _, _, tracer).

   yes

Протокол :ref:`monitoring <apis:monitoring/0>` объявляет обработчики событий ``public``-предикатами. При необходимости :ref:`protected or private implementation of the protocol <protocols_implementing>` можно использовать для изменения области действия предикатов обработчика событий. Обратите внимание, что механизм обработки отправки сообщений способен вызывать обработчики событий независимо от их области видимости. Область действия обработчиков событий можно ограничивать, чтобы предотвратить их вызов другими объектами.
