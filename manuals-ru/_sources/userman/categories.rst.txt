..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Если это не требуется законодательством или не согласовано в письменной форме, программное обеспечение
   распространяется по лицензии на условиях "КАК ЕСТЬ".,
   БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых.
   См. лицензию для конкретного языка, регулирующего разрешения и
   ограничения, предусмотренные Лицензией.


.. _categories_categories:

Категории
=========

Категории - это *функциональные блоки, задающие специальный набор связанных общей задачей операций, реализуюшие принцыпы повторного использования кода*, они рассматриваться как дуальнеая концепция протоколов. Категории предоставляют способ инкапсуляции множества
связанных предикатных деклараций и их реализаций, не решающих конкретную задачу, как это делает конкретный объект. Суть решения становится полностью определенными только тогда, когда категория входит в состав другого объекта, а пердикаты категории используют предикаты объекта. Категории также можно использовать для рездзеления сложного объекта на
функциональные блоки. Категория может быть импортирована несколькими разными объектами (что обеспечивает отсутствие дублирования кода), включая объекты, участвующие в иерархии прототипов или иерархии на основе классов. Концепция категорий разделяет некоторые идеи функциональных категорий языка  Smalltalk-80 [Goldberg83]_, Микс-инов [Moon86]_ (не обязательно при этом использовать множественное наследование), и категории Objective-C [Cox86]_. Категории могут также *дополнять* существующие объекты, тем самым обеспечивая механизм :term:`hot patching` (заменой методов во время исполнения программы), по аналогии с категориями Objective-C.

Logtalk определяет встроенную категорию ref:`core_messages <apis:core_messages>`,
которая описывается в конце раздела.</apis:core_messages>

.. _categories_defining:

Определение новой категории
---------------------------

Программирование новой категории делается так же, как и код Prolog, при помощи текстового редактора. Исходные файлы Logtalk могут содержать один или несколько
объектов, категори1 и протоколов. Если предпочитаете определять каждую сущность в собственном файле, то рекомендуется файл поименовывать в соответствии с названием категории. По умолчанию все исходные файлы Logtalk используют расширение
``.lgt``, однако, это можно поменять в файлах-адаптерах конкретных систем Prolog-программирования.
Промежуточные исходные файлы Prolog, генерируемые компилятором Logtalk,
по умолчанию имеют суффикс ``_lgt`` и расширение ``.pl``. Опять же, это можно настроить в соответствии с потребностями конкретного компилятора Prolog в соответствующем файле-адаптере. Например, можно определить категорию с именем ``documenting`` и сохраним ее в файле ``documenting.lgt``, которая затем будет скомпилирована в файл Prolog ``documenting_lgt.pl`` (в зависимости от :term:`backend compiler <backend prolog compiler>``). Имена временных файлов Prolog-а могут содержать хэш каталога и идентификатор процесса для предотвращения конфликтов имен файлов, если Logtalk-программа выполняется в качестве внедренной в другой процесс или в параллельном процессе.

Идентификаторы категорий могут быть атомами или составными терминами (при определении параметризованных категорий). Объекты, категории и протоколы разделяют общее пространство имен: нельзя задавать категорию с тем же именем, что и ранее определенные объект или протокол.

Реализация категории (директивы и предикаты) в тексте заелючены в
две директивы Logtalk: :ref:`directives_category_1_4` и
:ref:`directives_end_category_0`. Наиболее простой категорией выступает та, которая является автономной, не зависящей от какой-либо другой сущности Logtalk:

::

   :- category(Category).
       ...
   :- end_category.

Если категория реализует один или несколько протоколов, то открывающая определение
директива будет выглядеть следующим образом:

::

   :- category(Category,
       implements([Protocol1, Protocol2, ...])).
       ...
   :- end_category.

Категория может быть определена при помощи композиции других категорий:

::

   :- category(Category,
       extends([Category1, Category2, ...])).
       ...
   :- end_category.

Этим механизмом можно пользоваться только если в результате не будет нарушена уже существующая логика функциониирования. Простым примером расширения с множественным импортом выступает использование результируеющей категории в конкретных объектах, чтоб не повторять весь набор импортируемых категорий в каждом объекте. Однако такой импорт с повторениями - это все-таки предпочтительный способ использования нескольких категорий в объекте. Если в категории переопределяется какой-то предикат, ранее реализованный в одной из родительских категорий, то к предыдущему определению по-прежнему можно получить доступ при помощи управляющей конструкции :ref:`control_call_super_1`.

Категории не могут наследовать предикаты от объектов. ?? Кроме того, категории не могут определять динамические предикаты, т.е. не могут сами хранить состояние. Ограничение имеет смысл, поскольку она может быть импортирована несколькими объектами, а также потому что просто запрещено использовать предикаты управления базами данных в категориях (но можно отправлять сообщения объекту). ?? Однако категории могут содержать декларации динамических предикатов, они могут содержать предикаты, которые обрабатывают динамические предикаты. Например:

::

   :- category(attributes).

       :- public(attribute/2).
       :- public(set_attribute/2).
       :- public(del_attribute/2).

       :- private(attribute_/2).
       :- dynamic(attribute_/2).

       attribute(Attribute, Value) :-
           % вызывается в контексте "self"
           ::attribute_(Attribute, Value).

       set_attribute(Attribute, Value) :-
           % стирает старые фразы в "self"
           ::retractall(attribute_(Attribute, _)),
           % добавить фразу в базу данных "self"
           ::assertz(attribute_(Attribute, Value)).

       del_attribute(Attribute, Value) :-
           % удалить фразу в "self"
           ::retract(attribute_(Attribute, Value)).

   :- end_category.

Каждый объект, импортирующий эту категорию, будет иметь свой собственный   динамический ``private``-предикат ``attribute_/2``. Предикаты ``attribute/2``, ``set_attribute/2`` и ``del_attribute/2`` получают доступ к динамическим предикатам объекта, меняют их содержание при получении соответствующего сообщения (т.е. *self*). Но также можно определить предикаты, которые обрабатывают динамические предикаты, в контексте *this* вместо *self*. Например:

::

   :- category(attributes).

       :- public(attribute/2).
       :- public(set_attribute/2).
       :- public(del_attribute/2).

       :- private(attribute_/2).
       :- dynamic(attribute_/2).

       attribute(Attribute, Value) :-
           % доступ в контексте "this"
           attribute_(Attribute, Value).

       set_attribute(Attribute, Value) :-
           % удаление в контексте "this"
           retractall(attribute_(Attribute, _)),
           % добалени фразы в "this"
           assertz(attribute_(Attribute, Value)).

       del_attribute(Attribute, Value) :-
           % удалени фразы в "this"
           retract(attribute_(Attribute, Value)).

   :- end_category.

При определении категории, которая объявляет и обрабатывает динамические предикаты в контексте *this* связывает эти динамические предикаты с
объектом, импортирующим эту категорию. Если использовать контекст *self*, то это дает возможность во всех наследниках объекта, импортирующего категорию,
иметь свой собственный набор фраз для этих динамических предикатов.

.. _categories_patching:

Исправление объекта во время выполнения
---------------------------------------

Категория может также явным образом дополнять один или несколько существующих объектов, таким образом, обеспечивая функциональность :term:`hot patching`, реализованную по аналогии с категориями Objective-C:

::

   :- category(Category,
       complements([Object1, Object2, ....])).
       ...
   :- end_category.

Конструктция позволяет добавить отсутствующие директивы (например, определить
псевдонимы :term:`aliases <predicate alias>` для предикатов в объекте, к которому применяется процедура дополнения), заменить неработающие реализации предикатов, добавление новых предикатов, протоколов и категорий к существующим объектам без необходимости доступа и модификаций к исходному их коду. Распространенные сценарий использования - добавление записи событий в журнал или добавление отладочных предикатов к набору объектов. Дополняемые объекты должны быть скомпилированы
с помощью флага компилятора :ref:`complements <flag_complements>` с параметром ``allow`` (разрешить исправление или добавление новых функций) или ``restrict`` (разрешить только добавление новых функций). Дополняющая категория имеет преимущество перед ранее загруженной дополняющей категорией для того же объекта, что позволяет вносить исправления в предыдущие исправления.

При замене реализации предиката можно вызвать предыдущую реализацию в объекте из нового определения в категории, сообщив цель при помощи **экспериментального*** префиксного оператора ``@``. Такая декларация цели действительна только в контексте дополняющей категории и для предикатов, переопределяемых только во время исполнения программы. В качестве примера рассмотрим следующий объект:

::

   :- object(bird).

       :- set_logtalk_flag(complements, allow).

       :- public(make_sound/0).
       make_sound :-
           write('Chirp, chirp!'), nl.

   :- end_object.
   
Здесь используется вызов цели ``@`` для "обрамления" оригинальной реализации предиката ``make_sound/0``:

::

   :- category(logging,
       complements(bird)).

       make_sound :-
           write('Started making sound...'), nl,
           @make_sound,
           write('... finished making sound.'), nl.

   :- end_category.

После загрузки объекта и категории вызов предиката ``make_sound/0``
приведет к следующему результату:

.. code-block:: text

   | ?- bird::make_sound.
   
   Started making sound...
   Chirp, chirp!
   ... finished making sound.
   yes

Обратите внимание, что механизм поиска унаследованных реализаций (:term:``super calls <super call>``) будет вызывать унаследованные реализации дополняемого объекта, вместо реализаций в предках категории.
Это позволяет более филигранно исправлять объекты. Но это также означает, что если надо исправить объект таким образом, чтобы он импортировал категорию, которая наследует другую категорию и использует супервызовы к своим категориям-предкам, вам нужно будет реализовать (возможно, пустую) дополняющую категорию, которая наследует категорию, которую вы хотите добавить.

Использование механизма исправления объектов во время исполнения, к сожалению, отключает возможность оптимизации статического связывания (:term:`static binding`) для сообщений, отправляемых в исправляемый объект, так как он может быть позже дополнительно изменен.

Еще одно важное замечание - хоть и дополняющая категория заменяет реализацию предиката, но локальные вызовы замененного предиката по-прежнему будут идти в оригинальную неисправленную версию предиката. Отсутствие универсального переносимого решения на уровне
адаптеров компиляторов (:term:`backend Prolog compiler`) для замены статических определений предикатов.

.. _categories_finding:

Поиск реализованных категорий
-----------------------------

При помощи бэктрекинга все скомпилированные категории можно перечислить, делается это при помощи встроенного предиката :ref:`predicates_current_category_1` со
свободным аргументом:

.. code-block:: text

   | ?- current_category(Category).

Этот предикат также используется для проверки, существует ли категория, для этого передаем в параметр ее идентификатором или соответствующий составной терм.

.. _categories_creating:

Создание новой категории во время выполнения
--------------------------------------------

Категории можно создавать динамически во время выполнения программы с помощью
встроенного предиката :ref:`predicates_create_category_4`:

.. code-block:: text

   | ?- create_category(Category, Relations, Directives, Clauses).

Первый аргумент - либо переменная, либо имя новой категории (атом Prolog, который не должен совпадать с именем уже существующей сущности). Остальные три аргумента соответствуют отношениям, которые задаются в директиве начала описания категории, и содержимому кода категории (директивы и высказывания).

Например, вызов:

.. code-block:: text

   | ?- create_category(
            ccc,
            [implements(ppp)],
            [private(bar/1)],
            [(foo(X):-bar(X)), bar(1), bar(2)]
        ).

эквивалентен компиляции и загрузке категории:

::

   :- category(ccc,
       implements(ppp)).

       :- dynamic.

       :- private(bar/1).

       foo(X) :-
           bar(X).

       bar(1).
       bar(2).

   :- end_category.

Если нам нужно создать много (динамических) категорий во время выполнения, то
лучше всего реализовать метакласс или прототип с предикатом, который
будет вызывать этот встроенный предикат, чтобы обеспечить более специфическое
поведение.

.. _categories_abolishing:

Удаление существующей категории
-------------------------------

Динамические категории могут быть удалены из памяти процесса при помощи
встроенного предиката :ref:`predicates_abolish_category_1`:

.. code-block:: text

   | ?- abolish_category(Category).

Аргумент должен быть идентификатором существующей динамической категории,
в противном случае будет выдана ошибка.

.. _categories_directives:

Директивы, используемые в реализации категорий
----------------------------------------------

Директивы категорий используются для определения их свойств, для документирования зависимостей категорий от других сущностей Logtalk, а также для загрузки в нее содержимого файлов.

.. _categories_dynamic:

Динамические категории
~~~~~~~~~~~~~~~~~~~~~~

Как и Prolog, категория может статической, так и динамической. Категория, созданная во время выполнения программы, всегда
динамическая. Категория, определенная в файле, может быть как динамической, так и статической.
Динамические категории объявляются с помощью директивы :ref:`directives_dynamic_0`
в исходном коде категории:

::

   :- dynamic.

Директива должна предшествовать любым директивам спецификации предикатов и их реализациям. Имейте в виду, что использование динамического кода приводит к снижению производительности по сравнению со его статическим вариантом. Динамические категории имеет смысл использовать только тогда, когда
они должны быть по каким-то причинам удалены во время выполнения программы.

.. _categories_documentation:

Документирование категорий
~~~~~~~~~~~~~~~~~~~~~~~~~~

Категории следует документировать при помощи информации для пользователя, для этого есть директивы :ref:`directives_info_1'. Смотрите раздел
:ref:`documenting_documenting` для получения подробной информации.

.. _categories_include:

Загрузка файлов в категорию
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Директива :ref:`directives_include_1` используется для загрузки содержимого файла в категорию. Смотрите раздел :ref:`objects_objects`, где приведен пример использования этой
директивы.

.. _categories_object_aliases:

Задание псевдонимов объектам
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Директива :ref:`directives_uses_1` позволяет задавать псевдонимы объектам.
Типичное использование этой директивы заключается в сокращении длинных имен объектов и упрощении экспериментов с различными реализациями объектов одного и того же
протокола при использовании явной отправки сообщений.

.. _categories_relationships:

Отношения между категориями
---------------------------

Logtalk предоставляет два набора встроенных предикатов, позволяющих запрашивать систему о структуре связей, в которых состоит категория с другими объектами.

Встроенные предикаты :ссылка:`predicates_implements_protocol_2_3` и :ref:`predicates_conforms_to_protocol_2_3` предоставляют информацию о том, как категории реализуют протоколы:

.. code-block:: text

   | ?- implements_protocol(Category, Protocol, Scope).

или, если надо посмотреть унаследованные протоколы:

.. code-block:: text

   | ?- conforms_to_protocol(Category, Protocol, Scope).

Обратите внимание, что если передать в предикат свободный первый аргумент, то нам пред запросом надо запустить цель :ref:`predicates_current_category_1`, чтобы задать
возвращаемой сущности тип категории, а не любой объект.

Чтобы определить, какие объекты импортируют какие категории, используем
встроенные предикаты :ref:`predicates_imports_category_2_3`:

.. code-block:: text

   | ?- imports_category(Object, Category).

или, если надо узнать ограничения для пространства имен во время импорта:

.. code-block:: text

   | ?- imports_category(Object, Category, Scope).

Помним, что категория может быть импортирована несколькими объектами.

Чтобы найти, какие категории наследуют (расширяют) другие категории, можно использовать встроенные предикаты :ref:`predicates_extends_category_2_3`:

.. code-block:: text

   | ?- extends_category(Category1, Category2).

или, если нужно также пространство имен:

.. code-block:: text

   | ?- extends_category(Category1, Category2, Scope).

Любая категория может быть расширена несколькими категориями.

Чтобы найти, какие категории явно дополняют существующие объекты, можно
использовать встроенный предикат :ref:`predicates_complements_object_2`:

.. code-block:: text

   | ?- complements_object(Category, Object).

Обратите внимание, что категория может явно дополнять несколько объектов.

.. _categories_properties:

Свойства категории
------------------

Можем узнать информацию о свойствах существующих категорий, вызвав встроенный
предикат :ref:`predicates_category_property_2`:

.. code-block:: text

   | ?- category_property(Category, Property).

Поддерживаются следующие свойства категории:

``static``
   Категория статическая
``dynamic``
   Категория является динамической, и, следовательно, может быть удалена из памяти во время выполнения при помощи
   вызова встроенного предиката :ref:`predicates_abolish_category_1`)
``built-in``
   Категория является встроенной, и, таким образом, всегда доступна.
``file(Path)``
   Абсолютный путь к исходному файлу с исходным кодом категории (если
   такой есть)
``file(Basename, Directory)``
   Базовое имя и каталог исходного файла исходного кода категории (если
   такой имеется); ``Directory`` всегда заканчивается ``/``
``lines(BeginLine, EndLine)``
   Начальная и конечная строки определения категории в файле исходного кода(если
   такой имеется)
``events``
   Сообщения, отправленные из категории, генерируют события
``source_data``
   Исходные данные, доступные для категории
``public(Resources)``
   Список ``public``-предикатов и операторов, объявленных в категории
``protected(Resources)``
   Список ``private``-предикатов и операторов, объявленных в категории
``private(Resources)``
   Список ``private``-предикатов и операторов, объявленных в категории
``declares(Predicate, Properties)``
   Список свойств (:ref:`properties <grammar_entity_properties>`) предиката, декларированного в категории 
``defines(Predicate, Properties)``
   Список :ref:`properties <grammar_entity_properties>` для предиката, определенного в категории
``includes(Predicate, Entity, Properties)``
   Список :ref:`properties <grammar_entity_properties>` для многофайловых предикатов
   в указанном объекте (свойства включают
   ``number_of_clauses(Number)``, ``number_of_rules(Number)`` и
   ``line_count(Line)``, значение ``Line`` будет соответствовать
   первой фразе многофайлового предиката)
``provides(Predicate, Entity, Properties)``
   Список :ref:`properties <grammar_entity_properties>` для другого многофайлового предиката, который
   определен в категории (свойства включают
   ``number_of_clauses(Number)``, ``number_of_rules(Number)`` и
   ``line_count(Line)``, значение ``Line`` будет соответствовать
   первой фразе многофайлового предиката)
``alias(Predicate, Properties)``
   Список :ref:`properties <grammar_entity_properties>` для синонима (:term:`predicate alias`), объявленного в категории
   (список свойств включает ``for(Original)``, ``from(Entity)``,
   ``non_terminal(NonTerminal)`` и ``line_count(Line)``, при этом ``Line``
   будет равна номеру первой строки директивы ``alias``)
``calls(Call, Properties)``
   Список :ref:`properties <grammar_entity_properties>` вызовов предикатов, выполняемых категорией (``Call``
   - это или предикат или управляющая конструкция, такая как
   ``(::)/1-2`` или ``(^^)/1`` с аргументом-предикатом; при этом
   значение ``Call`` не может быть основным термом в случае вызова управляющей control
   структуры, если ее аргумент известен только во время выполнения; свойства
   включают ``caller(Caller)``, ``alias(Alias)`` и
   ``line_count(Line)``, при этом и ``Caller`` и ``Alias`` - 
   это предикаты, а ``Line`` - номер строки, где 
   в предикате или директиве выполняется вызов
``updates(Predicate, Properties)``
   Список :ref:`properties <grammar_entity_properties>` динамических обновлений предикатов (а также доступ
   используя предикат ``clause/2``), реализованный объектом (``Predicate``
   - это или предикат или управляющая конструкция, такая как
   ``(::)/1-2`` или ``(:)/2`` с предикатом в качестве аргумента; заметим, что
   значение ``Predicate`` не может быть основным термом в случае управляющей структуры,
   где аргумент известен время выполнения; свойства включают
   ``updater(Updater)``, ``alias(Alias)`` и ``line_count(Line)``, где
   ``Updater`` - это мозможно мультифайловый предикат,
   ``Alias`` - предикат и ``Line`` -
   номер первой строки реализации предиката или директивы, обновляющей предикат)
``number_of_clauses(Number)``
   Общее количество фраз предиката, заданных в категории (включает
   как определяемые пользователем высказывания, так и вспомогательные, генерируемые
   компилятором или механизмом :ref:`expansion hooks <expansion_expansion>`, но
   это число не включает фразы многофайловых предикатов, определенных для других
   сущностей, а также фраз категории, определенных многофайлово и
   предоставленных другими сущностями)
``number_of_rules(Number)``
   Общее количество правил предикатов, определенных в категории (включает
   как правила пользователя, так и вспомогательные правила, сгенерированные компилятором
   или механизмом :ref:`expansion hooks <expansion_expansion>`, но не
   включает правила для многофайловых предикатов, определенных для других сущностей, и
   правил для категории, заданной многофайлово, предикатов, созданных другими
   сущностями)
``number_of_user_clauses(Number)``
   Общее количество определяемых пользователем высказываний, определенных в
   категория (не включает фразы из многофайловых предикатов, определенных
   для других сущностей или фраз в категории, заданной многофайлово, а также
   предоставленными другими сущностями)
``number_of_user_rules(Number)``
   Общее количество пользовательских правил, определенных в категории
   это число не включает фразы многофайловых предикатов, определенных для других
   сущностей или правил в категории, реализованной многофайлово или полученных из внесенные
   других программных объектов)

Некоторые свойства, такие как номера строк, доступны только тогда, когда категория
определяется в исходном файле и скомпилирована с установленным флагом :ref:`source_data<flag_source_data>`. Кроме того, номера строк поддерживаются только в
:term:`backend Prolog compilers<backend Prolog compiler>`,
которые предоставляют доступ к начальной строке в процедуре чтения терма. Когда такая поддержка недоступна, возвращается значение ``-1`` и для начальной и для конечной строк.

Свойства, возвращающие количество фраз (правил), выдают фразы (правила), которые *текстово определены в объекте* как для многофайловых, так и для не-многофайловых предикатов. Таким образом, эти числа исключают фразы (правила)
для многофайловых предикатов *добавленных* другими сущностями.

.. _categories_importing:

Импорт категорий
----------------

Любое количество объектов может импортировать категорию. Кроме того, объект может импортировать любое количество категорий. Синтаксис очень простой:

::

   :- object(Object,
       imports([Category1, Category2, ...])).
       ...
   :- end_object.

Чтобы сделать все ``public``-предикаты, импортируемые через категорию, ``protected``- или ``private``-предикатами (также можно ``protected`` превратить в ``private``), к названию категории добавляется соответствующее ключевое слово:

::

   :- object(Object,
       imports(private::Category)).
       ...
   :- end_object.

или:

::

   :- object(Object,
       imports(protected::Category)).
       ...
   :- end_object.

Пропуск этого ключевого слова эквивалентно записи:

::

   :- object(Object,
       imports(public::Category)).
       ...
   :- end_object.

.. _categories_predicates:

Вызов предикатов, реализованных в категории
-------------------------------------------

Предикаты категории вызываются изнутри объекта при помощи отправки
сообщения *self*-у или при помощи *super*-вызова. Рассмотрим следующую категорию:

::

   :- category(output).

       :- public(out/1).

       out(X) :-
           write(X), nl.

   :- end_category.

Предикат ``out/1`` вызывается из объекта, импортирующего
категорию, отправив сообщение *self*-у (себе). Например:

::

   :- object(worker,
       imports(output)).

       ...
       do(Task) :-
           execute(Task, Result),
           ::out(Result).
       ...

   :- end_object.

Это рекомендуемый способ вызова предиката категории, который может быть
специализирован/переопределен далее при наследовании (расширении), так как поиск реализации предиката начнется с *self*.

Прямой вызов определения предиката импортированной категории, выполняется при помощи управляющей конструкции :ref:`control_call_super_1`. Например:

::

   :- object(worker,
       imports(output)).

       ...
       do(Task) :-
           execute(Task, Result),
           ^^out(Result).
       ...

   :- end_object.

Этот вариант следует использовать только тогда, когда пользователь априори знает, что
предикаты категории не будут специализироваться или переопределены в потомках объекта, импортирующего категорию. Его преимущество заключается в том, что если флаг :ref:`optimize <flag_optimize>` включен при компиляции Logtalk, система попытается оптимизировать вызовы с помощью
статического связывания :term:`static binding`. Если используется :term:`dynamic binding`, например из-за отсутствия достаточной информации во время компиляции, производительность будет примерно соответствовать вызову предиката категории, запрашивая :term:`self` (в обоих случаях используется механизм кэширования поиска предиката в объектной иерархии).

.. _categories_parametric:

Параметризованные категории
---------------------------

Предикаты категории могут быть параметризованы таким же образом, как и предикаты объекта, используя составной терм в качестве идентификатора категории, в этом терме все аргументы должны быть переменными. К этим переменным, *параметрам категории*, можно получить доступ при помощи встроенных методов :ref:`methods_parameter_2` и :ref:`methods_this_1` в
категории или при помощи :term:`parameter variables <parameter variable>`.
Значения параметров категории могут быть определены импортирующими объектами.
Например:

::

   :- object(speech(Season, Event),
       imports([dress(Season), speech(Event)])).
       ...
   :- end_object.

Доступ к параметрам категории возможен только внутри категории. В частности, вызовы встроенного метода :ref:`methods_this_1` из предикатов категории всегда обращаются к идентификатору импортирующего объекта, и, следовательно, к параметрам объекта, а не к параметрам категории.

.. _categories_built_in:

Встроенные категории
--------------------

Logtalk определяет встроенную категорию, которая всегда доступна всем приложениям.

.. _categories_core_messages:

Встроенная категория `core_messages`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Встроенная категория :ref:`core_messages <apis:core_messages/0>` предоставляет
переводы по умолчанию для всех выводимых на стандартный вывод сообщений компилятора и среды выполнения, таких как предупреждения и ошибки. Она не определяет никаких ``public``-предикатов.
