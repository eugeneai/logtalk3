..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


.. _declarative_declarative:

Декларативное объектно-ориентированное программирование
=======================================================

Logtalk - это *декларативный объектно-ориентированный логический язык программирования*. Это означает, что Logtalk разделяет ключевые концепции с другими объектно-ориентированными языками программирования, но абстрагирует и переосмысливает эти концепции в контексте декларативного логического программирования.

Ключевыми понятиями в *декларативном* объектно-ориентированном программировании являются *инкапсуляция* и *шаблоны повторного использования*. Примечательно, что концепция *изменяемого состояния*, которая относится к *императивному* программированию, не является значимой концепцией в *декларативном* объектно-ориентированном программировании.
Декларативные концепции объектно-ориентированного программирования могут быть материализованы как в логических, так и в функциональных языках. В этом разделе рассмотрим только на декларативном
объектно-ориентированном логическом программировании.

Первым критическим обобщением концепций объектно-ориентированного программирования является концепция объекта как такового. То, что инкапсулирует объект, зависит от *базовой парадигмы программирования*, относимой к объектно-ориентированному программированию. Когда эти концепции применяются к императивному языку, где центральное место занимают изменяемое состояние и деструктивное присвоение, объекты естественным образом инкапсулируют и абстрагируют изменяемое состояние, обеспечивая
упорядоченный доступ и модификацию. Когда эти концепции применяются к языку декларативной логики, такому как Prolog, объекты естественным образом инкапсулируют предикаты. Следовательно, объект можно рассматривать как *теорию*, выраженную набором связанных предикатов. Теории обычно статичны, и поэтому объекты Logtalk по умолчанию статичны. Это контрастирует с императивными объектно-ориентированными языками, где обычно классы статичны, а объекты динамичны. Этот взгляд на объект как на набор предикатов также исключает различие
между *данными * и *процедурами* (методами, операциями), которое является центральным для императивных объектно-ориентированных языков, но спорным в декларативных, гомоиконических логических языках.

Второе критическое обобщение касается связи между объектами и другими
сущностями, такими как протоколы (интерфейсы) и объектами-предками. Идея заключается в том, что отношения сущностей определяют *шаблоны повторного использования* и *роли*, которые они там играют.
Распространенным шаблоном повторного использования является *наследование*. В этом случае сущность наследует и, таким образом, повторно использует ресурсы от сущности-предка. В шаблоне повторного использования каждый участвующий объект играет определенную *роль*. Однако одна и та же сущность может играть несколько ролей в зависимости от ее отношений с другими сущностями. Например, объект может играть роль класса для своих экземпляров, роль подкласса для своих суперклассов и роль экземпляра для своего метакласса. Другим распространенным шаблоном повторного использования является *реализация протокола*. В этом случае объект, реализующий протокол, повторно использует свои объявления предикатов, предоставляя реализацию для этих предикатов и предоставляя эти предикаты своим клиентам в качестве "точек доступа". Существенным следствием этого обобщения является то, что протоколы, объекты и категории являются объектами первого класса, в то время как, например, *прототип*, *родитель*, *класс*, *экземпляр*, *метакласс*, *подкласс*, *суперкласс* или *предок* - это просто *роли*, которые объект может играть. Более того, язык может предоставлять несколько шаблонов повторного использования вместо выбора набора шаблонов и поддержки этого набора в качестве выбора дизайна, который исключает другие шаблоны повторного использования. 
Например, большинство императивных объектно-ориентированных языков основаны либо на классах, либо на прототипах. Напротив, Logtalk естественным образом поддерживает как классы, так и прототипы, предоставляя соответствующие шаблоны повторного использования, используя объекты как сущности первого класса, способные играть несколько ролей.
