..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Если это не требуется законодательством или не согласовано в письменной форме, программное обеспечение
   распространяется по лицензии на условиях "КАК ЕСТЬ".,
   БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых.
   См. лицензию для конкретного языка, регулирующего разрешения и
   ограничения, предусмотренные Лицензией.


.. _declarative_declarative:

Декларативное объектно-ориентированное программирование
=======================================================

Logtalk - это *декларативный объектно-ориентированный логический язык программирования*. Это означает, что Logtalk разделяет ключевые концепции с другими объектно-ориентированными языками программирования, но абстрагирует и переосмысливает эти концепции в контексте декларативного логического программирования.

Ключевыми понятиями в *декларативном* объектно-ориентированном программировании являются *инкапсуляция* и *шаблоны повторного использования*. Примечательно, что концепция *изменяемого состояния*, которая относится к *императивному* программированию, не является значимой концепцией в *декларативном* объектно-ориентированном программировании.
Декларативные концепции объектно-ориентированного программирования могут быть материализованы как в логических, так и в функциональных языках. В этом разделе рассмотрим только на декларативном
объектно-ориентированном логическом программировании.

Первым критическим обобщением концепций объектно-ориентированного программирования является концепция объекта как такового. То, что инкапсулирует объект, зависит от *базовой парадигмы программирования*, относимой к объектно-ориентированному программированию. Когда эти концепции применяются к императивному языку, где центральное место занимают изменяемое состояние и деструктивное присвоение, объекты естественным образом инкапсулируют и абстрагируют изменяемое состояние, обеспечивая
упорядоченный доступ и модификацию. Когда эти концепции применяются к языку декларативной логики, такому как Prolog, объекты естественным образом инкапсулируют предикаты. Следовательно, объект можно рассматривать как *теорию*, выраженную набором связанных предикатов. Теории обычно статичны, и поэтому объекты Logtalk по умолчанию статичны. Это контрастирует с императивными объектно-ориентированными языками, где обычно классы статичны, а объекты динамичны. Этот взгляд на объект как на набор предикатов также исключает различие
между *данными * и *процедурами* (методами, операциями), которое является центральным для императивных объектно-ориентированных языков, но спорным в декларативных, гомоиконических логических языках.

Второе критическое обобщение касается связи между объектами и другими
сущностями, такими как протоколы (интерфейсы) и объектами-предками. Идея заключается в том, что отношения сущностей определяют *шаблоны повторного использования* и *роли*, которые они там играют.
Распространенным шаблоном повторного использования является *наследование*. В этом случае сущность наследует и, таким образом, повторно использует ресурсы от сущности-предка. В шаблоне повторного использования каждый участвующий объект играет определенную *роль*. Однако одна и та же сущность может играть несколько ролей в зависимости от ее отношений с другими сущностями. Например, объект может играть роль класса для своих экземпляров, роль подкласса для своих суперклассов и роль экземпляра для своего метакласса. Другим распространенным шаблоном повторного использования является *реализация протокола*. В этом случае объект, реализующий протокол, повторно использует свои объявления предикатов, предоставляя реализацию для этих предикатов и предоставляя эти предикаты своим клиентам в качестве "точек доступа". Существенным следствием этого обобщения является то, что протоколы, объекты и категории являются объектами первого класса, в то время как, например, *прототип*, *родитель*, *класс*, *экземпляр*, *метакласс*, *подкласс*, *суперкласс* или *предок* - это просто *роли*, которые объект может играть. Более того, язык может предоставлять несколько шаблонов повторного использования вместо выбора набора шаблонов и поддержки этого набора в качестве выбора дизайна, который исключает другие шаблоны повторного использования. 
Например, большинство императивных объектно-ориентированных языков основаны либо на классах, либо на прототипах. Напротив, Logtalk естественным образом поддерживает как классы, так и прототипы, предоставляя соответствующие шаблоны повторного использования, используя объекты как сущности первого класса, способные играть несколько ролей.
