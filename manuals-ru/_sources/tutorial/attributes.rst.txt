..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


Динамические атрибуты объекта
=========================

В этом примере проиллюстрируем использование:

-  категорий
-  предикатов категорий
-  динамических предикатов

задавая категорию, реализующую набор предикатов для поддержки
динамических атрибутов для объекта.

.. _category:

Определение категории
-------------------

Задача - задать набор предикатов для обработки динамических атрибутов объекта. Потребуются public-предикаты для создания, получения и удаления
атрибутоа и динамический private-предикат для хранения значений для этих атрибутов. Назовем эти предикаты ``set_attribute/2`` и
``get_attribute/2``, используемые для получения и установки значения некоторого атрибута,
``del_attribute/2`` и ``del_attributes/2`` - для удаления атрибутов,
а ``attribute_/2`` будут хранить значения атрибутов.

Предположим, что по каким-то причинам мы не хотим инкапсулировать эти предикаты в объект. Почему?
Потому что перечисленные предикаты представляют собой набор тесно связанных отношений, которые могут использоваться в нескольких несвязанных объектах. Если их задать в объекте, то придется использовать наследование, чтобы в других объектах дать возможность ими пользоваться. Кроме того, может быть мы вынуждены будем использовать наследование от нескольких объектов или придется создать универсальный корневой объект, содержащий полный набор предикатов, реализующих полезные отношения и функции.

В такой ситуации Logtalk позволяет программисту инкапсулировать предикаты в *category* (категорию), что дает возможность их использовать в
любом объекте. Категория - это сущность Logtalk, очень близкая к объектам
и протоколам. Она содержит и директивы и определения предикатов.
Предикаты, заданные с категориях, могут быть импортированы в любой объект, обеспечивая отсутствие дублирования кода без использования наследования.

При определении предикатов категорий необходимо учитывать, что категория
может быть импортирована более чем одним объектом. То есть, вызовы встроенных методов, управляющих динамическими предикатами (таких как :ref:`methods_assertz_1` и :ref:`methods_retract_1`) должны выполняться или в контексте *self*, используя управляющую конструкцию *сообщение к self* (сообщение к самому себе) :ref:`control_send_to_self_1`, или в контексте *this* (т.е. в контексте объекта, импортирующего категорию). Такой подход гарантирует, что вызовы предикатов поддержки динамических атрибутов
будут использовать ``attribute_/2``, определенные в объекте. Реализуем предикаты, что достаточно просто. Например, если надо хранить атрибуты в
*self*:

::

   :- category(attributes).

       :- public(set_attribute/2).
       :- mode(set_attribute(+nonvar, +nonvar), one).

       :- public(get_attribute/2).
       :- mode(get_attribute(?nonvar, ?nonvar), zero_or_more).

       :- public(del_attribute/2).
       :- mode(del_attribute(?nonvar, ?nonvar), zero_or_more).

       :- public(del_attributes/2).
       :- mode(del_attributes(@term, @term), one).

       :- private(attribute_/2).
       :- mode(attribute_(?nonvar, ?nonvar), zero_or_more).
       :- dynamic(attribute_/2).

       set_attribute(Attribute, Value):-
           ::retractall(attribute_(Attribute, _)),
           ::assertz(attribute_(Attribute, Value)).

       get_attribute(Attribute, Value):-
           ::attribute_(Attribute, Value).

       del_attribute(Attribute, Value):-
           ::retract(attribute_(Attribute, Value)).

       del_attributes(Attribute, Value):-
           ::retractall(attribute_(Attribute, Value)).

   :- end_category.

Если надо хранить атрибуты в *this*, то просто удалите структуры ``(::)/1`` из
вышепреведенного кода.

В коде использованы вде новые директивы :ref:`directives_category_1_4` и
:ref:`directives_end_category_0`, задающие и инкапсулирующие содержимое категории. При необходимости можно задекларировать предикаты в протоколе (protocol), а в категорию поместить их реализацию:

::

   :- category(attributes,
       implements(attributes_protocol)).

       ...

   :- end_category.

Протоколы реализуются либо объектами, либо категориями, либо и тем,
и другим.

.. _importing:

Импорт категории
----------------------

Использовать предикаты в объекте можно после импорта категории:

::

   :- object(person,
       imports(attributes)).

       ...

   :- end_object.

После компиляции и загрузки объекта и категории, можно попробовать выполнить
запросы:

.. code-block:: text

   | ?- person::set_attribute(name, paulo).

   yes

   | ?- person::set_attribute(gender, male).

   yes

   | ?- person::get_attribute(Attribute, Value).

   Attribute = name, Value = paulo ;
   Attribute = gender, Value = male ;
   no

Резюме
-------

-  Категории похожи на объекты: просто программируем наши предикаты
   directives and definitions bracketed by opening and ending category
   directives.

-  Объект использует категорию, импортируя ее. Импортированные предикаты
   ведут себя также, как если бы они были определены в самом объекте.

-  Когда следует использовать категорию вместо объекта с наследованием? Всякий раз, когда у нас есть
   набор близких предикатов, которые повторно используются в нескольких,
   несвязанных объектах, например ничего не наследующих друг у друга.
     Таким образом, категории можно интерпретировать как компоненты, конструирующие объекты.
    
