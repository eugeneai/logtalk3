..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Если это не требуется законодательством или не согласовано в письменной форме, программное обеспечение
   распространяется по лицензии на условиях "КАК ЕСТЬ".,
   БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых.
   См. лицензию для конкретного языка, регулирующего разрешения и
   ограничения, предусмотренные Лицензией.


Исследование производительности программы
=========================================

В этом примере проиллюстрируем использование:

-  событий
-  мониторов

при помощи определения простого профайлера, отображающего на экран время начала и окончания обработки сообщения, отправленного какому-либо объекту.

.. _profiling_events:

Сообщения - это события
-----------------------

В "чистых" объектно-ориентированных системах все вычисления базируются на отправке
сообщений объектам. *Событием* (``event``) называется факт отправки сообщения объекту. Данные о нем задаются кортежем ''(Объект, Сообщение, Отправитель)''. Если смотреть на процесс взаимодействия объектов детально, то посылка сообщения - это последовательность, состоящая из отправки сообщения и возврата управления объекту-отправителю, порождающих два отдельных события. Такие события относятся к фазам ''до'' (``before``) и ''после'' (``after``), соответственно. В конечном итоге приходим к представлению события в виде кортежа
''(Событие, Объект, Сообщение, Отправитель)''. Например, посылка сообщения

.. code-block:: text

   | ?- foo::bar(X).

   X = 1
   yes

породит два события:

.. code-block:: text

   (before, foo, bar(X), user)
   (after, foo, bar(1), user)

Обратите внимание, что второе событие сгенерируется только в том случае, если сообщение выполнено успешно. Если вызов сообщения имеет несколько ответо-решений, событие ''after''
будет сгенерировано для каждого отдельного решения.

События автоматически генерируются механизмами отправки сообщений для
каждого ``public``-предиката, отправленного при помощи оператора:ref:'control_send_to_object_2'.

.. _profiling_monitors:

Реализация профилера при помощи мониторов
-----------------------------------------

Монитор — это объект, который получает управление всякий раз, когда происходит событие, за которым он следит. Реакция монитора на события определяются двумя обработчиками событий:
:ref:'methods_before_3' для событий типа ''before''
и :ref:'methods_after_3' для событий типа ''after''. Эти предикаты автоматически вызываются механизмом отправки сообщений
при возникновении событий, зарегистрированных для монитора. Обработчики событий объявлены ``public``-предикатами в протоколе ''monitoring''.

В нашем примере надо получать моменты времени до и после
обработки сообщения. Предположим, что есть специальный объект ``time``, в котором реализован
предикат ``cpu_time/1``, возвращающий время процессора для текущего сеанса Prolog:

::

   :- object(time).

       :- public(cpu_time/1).
       :- mode(cpu_time(-number), one).
       ...

   :- end_object.

Наш профайлер будет называться ``stop_watch``. Определим обработчики событий ``before`` и ``after``, отображающие содержание кортежа события (объект, сообщение, отправитель), а также текущее время:

::

   :- object(stop_watch,
       % предикаты, реализующие протокол перехвата сообщений
       implements(monitoring)).

       :- uses(time, [cpu_time/1]).

       before(Object, Message, Sender) :-
           write(Object), write(' <-- '), writeq(Message),
           write(' from '), write(Sender), nl, write('STARTING at '),
           cpu_time(Seconds), write(Seconds), write(' seconds'), nl.

       after(Object, Message, Sender) :-
           write(Object), write(' <-- '), writeq(Message),
           write(' from '), write(Sender), nl, write('ENDING at '),
           cpu_time(Seconds), write(Seconds), write(' seconds'), nl.

   :- end_object.

После компиляции и загрузки объекта ``stop_watch`` (а также объектов,
за которыми хотим следить) можно настроить наш профайлер при помощи встроенного предиката:ref:`predicates_define_events_5`. Например, чтобы профилировать все сообщения, отправляемые объекту ``foo``, нам нужно вызвать цель:

.. code-block:: text

   | ?- define_events(_, foo, _, _, stop_watch).

   yes

Вызов зарегистрирует ``stop_watch`` в качестве одного монитора для всех отправленных сообщений ``foo``, включая оба типа события ``before`` и ``after``. Обратите внимание, что мы говорим «в качестве одного монитора», а не «единственного монитора»: можно задать любое количество объектов-мониторов, отслеживающих одни и те же события.

Теперь каждый раз, когда отправляляется сообщение ``foo``, монитор ``stop_watch``
распечатает время начала и окончания исполнения сообщения. Пример:

.. code-block:: text

   | ?- foo::bar(X).

   foo <-- bar(X) from user
   STARTING at 12.87415 seconds
   foo <-- bar(1) from user
   ENDING at 12.87419 seconds

   X = 1
   yes

Чтобы остановить отслеживание сообщений, отправленных ``foo``, используется
встроенный предикат :ref:`predicates_abolish_events_5`:

.. code-block:: text

   | ?- abolish_events(_, foo, _, _, stop_watch).

   yes

Вызов отключит все события, определенные над объектом ``foo`` и ранее
назначеные монитору ``stop_watch``.

Резюме
-------

-  Событие - это факт отправки ``public``-сообщения
    

-  Существует два тип событий: события ``before``, генерируемое перед посылкой
   сообщения, и ``after``, генеруемое после
   завершения обработки сообщения, при условии, что обработка завершилась успешно.

-  Любой объект может быть объявлен в качестве монитора событий. Монитор должен
   ссылатся на встроенный протокол ``monitoring`` в начале определения объекта.
    

-  Монитор должен определить обработчики событий, т.е. предикаты
   :ref:`methods_before_3` и :ref:`methods_after_3`, которые
   автоматически вызываются механизмами среды выполнения при возникновении отслеживаемого события.

-  Три встроенных предиката: :ref:`predicates_define_events_5`,
   :ref:`predicates_current_event_5` и
   :ref:`predicates_abolish_events_5`,
   позволяют задавать, запрашивать состояние мониторинга и отключать мониторинг событий.
