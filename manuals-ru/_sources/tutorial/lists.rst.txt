..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Если это не требуется законодательством или не согласовано в письменной форме, программное обеспечение
   распространяется по лицензии на условиях "КАК ЕСТЬ".,
   БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых.
   См. лицензию для конкретного языка, регулирующего разрешения и
   ограничения, предусмотренные Лицензией.


Предикаты обработки списков
===============

В этом примере проиллюстрируем использование:

-  объектов
-  протоколов

при помощи инкапсуляции предикатов "обработки" списков.

.. _object:

Определение объекта для списков
----------------------

Начнем с определения объекта ``list``, содержащего предикаты,
реализующие привычные манипуляции со списками, например``append/3``,
``length/2`` и ``member/2``:

::

   :- object(list).

       :- public([
           append/3, length/2, member/2
       ]).

       append([], List, List).
       append([Head| Tail], List, [Head| Tail2]) :-
           append(Tail, List, Tail2).

       length(List, Length) :-
           length(List, 0, Length).

       length([], Length, Length).
       length([_| Tail], Acc, Length) :-
           Acc2 is Acc + 1,
           length(Tail, Acc2, Length).

       member(Element, [Element| _]).
       member(Element, [_| List]) :-
           member(Element, List).

   :- end_object.

В чем здесь отличается от обычной программы Prolog? Определения предикатов списков нам знакомы. У нас есть две новые директивы,
:ref:'directives_object_1_5' и
:ref:'directives_end_object_0', они
инкапсулируют код в объект. В Logtalk по умолчанию все предикаты объекта находятся в области видимости ``private``, и предикаты, доступные "снаружи" должны быть объявлены как ``public``. Такая декларация задается при помощи директивы области видимости
:ref:'directives_public_1'.

Код объекта сохраним в текстовый файл под именем ''list.lgt''. Сохранять свой код нужно в рабочий каталог, расположение которого зависит от интерпретатора Prolog (обратитесь к справочному руководству интерпретатора).
Затем запустим Logtalk (см.
раздел :ref:'Установка и запуск Logtalk <installing_installing>' в
руководстве пользователя), скомпилируем и загрузим объект при помощи встроенного в Logtalk предиката :ref:'predicates_logtalk_load_1':</installing_installing>

.. code-block:: text

   | ?- logtalk_load(list).

   object list loaded
   yes

Теперь попробуем запустить цель:

.. code-block:: text

   | ?- list::member(X, [1, 2, 3]).

   X = 1;
   X = 2;
   X = 3;
   no

или:

.. code-block:: text

   | ?- list::length([1, 2, 3], L).

   L = 3
   yes

Инфиксный оператор
:ref:'control_send_to_object_2' используется в
Logtalk для отправки сообщения объекту. Сообщение должно соответствовать сигнатуре ``public``-предиката объекта. Если попытаемся назвать не-``public``-предикат, такой как
''length/3'' например, то будет сгенерировано исключение:

.. code-block:: text

   | ?- list::length([1, 2, 3], 0, L).

   uncaught exception:
       error(
           existence_error(predicate_declaration, length/3),
           logtalk(list::length([1,2,3],0,_), ...)
       )   

Исключение описывает разновидность ошибки и контекст,
где произошла ошибка.

.. _protocol:

Определение протокола для списка
--------------------------------

Как было видно в приведенном выше примере, объект Logtalk состоит из директив, декларирующих предикаты, и реализаций кода предикатов (предложений). Совокупность директив предикатов формируют *протокол* или интерфейс объекта. Интерфейс может иметь несколько реализаций. Например, можно определить новый объект, реализующий предикаты "обработки" списков с использованием разностных представлений. При этом повторять все директивы в новом объекте мы не будем. Нужно выделить из объекта протокол, оставив объекту реализацию. Протокол задается в Logtalk при помощи сущности ``protocol``. Протоколы Logtalk сходны с объектами и категориями. Определим протокол ''listp'':

::

   :- protocol(listp).

       :- public([
           append/3, length/2, member/2
       ]).

   :- end_protocol.

Используем директивы :ref:'directives_protocol_1_2' и :ref:'directives_end_protocol_0' для инкапсуляции директив предикатов в протокол аналогично тому, как мы задавали объект. Также можно улучшить протокол, отдокументировав варианты вызова/возврата (``call``/``return``) и
количество ответов каждого предиката при помощи директивы :ref:'directives_mode_2':

::

   :- protocol(listp).

       :- public(append/3).
       :- mode(append(?list, ?list, ?list), zero_or_more).

       :- public(length/2).
       :- mode(length(?list, ?integer), zero_or_more).

       :- public(member/2).
       :- mode(member(?term, ?list), zero_or_more).

   :- end_protocol.

Теперь нужно изменить определение нашего объекта ''list'', удалив
директивы предикатов и добавив объявление реализуемого
протокола ''listp'':

::

   :- object(list,
       implements(listp)).

       append([], List, List).
       append([Head| Tail], List, [Head| Tail2]) :-
           append(Tail, List, Tail2).
       ...

   :- end_object.

Протокол ''listp'' теперь задействуем при реализации варианта объекта с
использованием разностного представления списков, объекта ''difflist'':

::

   :- object(difflist,
       implements(listp).

       append(L1-X, X-L2, L1-L2).
       ...

   :- end_object.

Резюме
-------

*  Для того чтобы определить простой объект просто вставьте код Prolog
   между начальной и конечной директивами объекта и добавьте необходимые
   директивы области видимости. Такой объект готов к использованию без каких-либо дополнительных манипуляций.

*  Определяйте протоколы, если предполагается создать несколько
   альтернативных определений некоторому набору предикатов. Таким образом, мы
   избегаем повтороного оределения директив предикатов.
