..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


Рефлексивная система классов
============================

Во время компилирования объекта Logtalk различает прототипы, классы и экземпляры классов в зависимости от того, в каких отношениях состоят эти объекты. Если объект является экземпляром другого объекта или специализирует другой объект (унаследован от другого объекта), то он компилируется, соответственно, как экземпляр или класс, в противном случае он компилируется как прототип. Поэтому для создания иерархии классов и экземпляров необходимо разработать корневой набора объектов, при этом мы не ограничены лишь одной иерархией. Типосное решение представляет собой определение *рефлексивной* системы [Maes87]_ на основе классов, где каждый класс также является экземпляром некоторого класса.

В этом примере определим базовую систему объектов для такой рефлексивной системы
классов, развивающей идеи из [Cointe87]_. Такое расширение предоставляет, наряду с корневыми объектами для создания экземпляров и иерархии классов, явную поддержку абстрактных классов [Moura94]_.

.. _classes:

Определение базового набора классов
-----------------------------------

Начнем с определения трех классов: ``object``, ``abstract_class``,
и собственно ``класс``. Класс ``object`` содержит предикаты, которые могут использоваться всеми объекты. Он будет корнем графа наследования:

::

   :- object(object,
       instantiates(class)).

       % предикаты, доступные всем объектам

   :- end_object.

Класс ``abstract_class`` - это экземпляр ``object``, он добавляет редикаты, доступные всем классам. Он будет мета-классом по умолчанию для абстрактных классов:

::

   :- object(abstract_class,
       instantiates(class),
       specializes(object)).

       % предикаты, доступные всем классам

   :- end_object.

Класс ``class`` - это экземпляр ``abstract_class``, в нем определяются предикаты, доступные всем классам, из которых порождаются объекты-экземпляры. Этот класс - корень иерархии экземпляров, также он является метаклассом по умолчанию для классов, из которых порождаются экземпляры:

::

   :- object(class,
       instantiates(class),
       specializes(abstract_class)).

       % прдикаты, доступые всем классам, имеющим экземпляры

   :- end_object.

Обратите внимание, что все три объекта являются экземплярами класса ``class``. Отношения создания экземпляров и специализации выбираются таким образом, чтобы каждый объект мог использовать предикаты, определенные в самом себе и в двух других объектах верхней части иерархии, без выпадения в бесконечный цикл term:`message lookup`.

Резюме
-------

-  Объект, от которого не создаются экземпляры и не являющийся специализацией  других объектов, 
   всегда компилируется как прототипа.

-  Объект-экземпляр должен быть экземпляром хотя бы одного объекта (своего класса).
   Аналогичным образом, класс должен или быть унаследован от другого класса или от него должны быть созданы экземпляры.
    

-  Различие между абстрактными классами и классами, имеющими экземпляры
   проявляется только в наборе декларированных и реализованных операций, включая унаследованные. Класс
   может иметь экземпляры, если наследует методы для их создания.
   И наоборот, класс является абстрактным, если не наследует ни одного метода создания экземпляров.
    
