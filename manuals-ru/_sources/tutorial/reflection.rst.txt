..
   Этот файл является частью проекта Logtalk <https://logtalk.org/>  
   Copyright 1998-2022 Paulo Moura <pmoura@logtalk.org>
   Идентификатор лицензии SPDX: Apache-2.0

   Лицензируется в соответствии с лицензией Apache, версия 2.0 (далее «Лицензия»);
   вы не можете использовать этот файл иначе, как в соответствии с Лицензией.
   Вы можете получить копию Лицензии на

       http://www.apache.org/licenses/LICENSE-2.0

   Если это не требуется законодательством или не согласовано в письменной форме, программное обеспечение
   распространяется по лицензии на условиях "КАК ЕСТЬ".,
   БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых.
   См. лицензию для конкретного языка, регулирующего разрешения и
   ограничения, предусмотренные Лицензией.


Рефлексивная система классов
============================

Во время компилирования объекта Logtalk различает прототипы, классы и экземпляры классов в зависимости от того, в каких отношениях состоят эти объекты. Если объект является экземпляром другого объекта или специализирует другой объект (унаследован от другого объекта), то он компилируется, соответственно, как экземпляр или класс, в противном случае он компилируется как прототип. Поэтому для создания иерархии классов и экземпляров необходимо разработать корневой набора объектов, при этом мы не ограничены лишь одной иерархией. Типосное решение представляет собой определение *рефлексивной* системы [Maes87]_ на основе классов, где каждый класс также является экземпляром некоторого класса.

В этом примере определим базовую систему объектов для такой рефлексивной системы
классов, развивающей идеи из [Cointe87]_. Такое расширение предоставляет, наряду с корневыми объектами для создания экземпляров и иерархии классов, явную поддержку абстрактных классов [Moura94]_.

.. _classes:

Определение базового набора классов
-----------------------------------

Начнем с определения трех классов: ``object``, ``abstract_class``,
и собственно ``класс``. Класс ``object`` содержит предикаты, которые могут использоваться всеми объекты. Он будет корнем графа наследования:

::

   :- object(object,
       instantiates(class)).

       % предикаты, доступные всем объектам

   :- end_object.

Класс ``abstract_class`` - это экземпляр ``object``, он добавляет редикаты, доступные всем классам. Он будет мета-классом по умолчанию для абстрактных классов:

::

   :- object(abstract_class,
       instantiates(class),
       specializes(object)).

       % предикаты, доступные всем классам

   :- end_object.

Класс ``class`` - это экземпляр ``abstract_class``, в нем определяются предикаты, доступные всем классам, из которых порождаются объекты-экземпляры. Этот класс - корень иерархии экземпляров, также он является метаклассом по умолчанию для классов, из которых порождаются экземпляры:

::

   :- object(class,
       instantiates(class),
       specializes(abstract_class)).

       % прдикаты, доступые всем классам, имеющим экземпляры

   :- end_object.

Обратите внимание, что все три объекта являются экземплярами класса ``class``. Отношения создания экземпляров и специализации выбираются таким образом, чтобы каждый объект мог использовать предикаты, определенные в самом себе и в двух других объектах верхней части иерархии, без выпадения в бесконечный цикл term:`message lookup`.

Резюме
-------

-  Объект, от которого не создаются экземпляры и не являющийся специализацией  других объектов, 
   всегда компилируется как прототипа.

-  Объект-экземпляр должен быть экземпляром хотя бы одного объекта (своего класса).
   Аналогичным образом, класс должен или быть унаследован от другого класса или от него должны быть созданы экземпляры.
    

-  Различие между абстрактными классами и классами, имеющими экземпляры
   проявляется только в наборе декларированных и реализованных операций, включая унаследованные. Класс
   может иметь экземпляры, если наследует методы для их создания.
   И наоборот, класс является абстрактным, если не наследует ни одного метода создания экземпляров.
    
